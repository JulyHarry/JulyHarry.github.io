# 第 385 场周赛

## [最长公共前缀的长度](https://leetcode.cn/problems/find-the-length-of-the-longest-common-prefix/)

> 给你两个 **正整数** 数组 `arr1` 和 `arr2` 。
>
> 正整数的 **前缀** 是其 **最左边** 的一位或多位数字组成的整数。例如，`123` 是整数 `12345` 的前缀，而 `234` **不是** 。
>
> 设若整数 `c` 是整数 `a` 和 `b` 的 **公共前缀** ，那么 `c` 需要同时是 `a` 和 `b` 的前缀。例如，`5655359` 和 `56554` 有公共前缀 `565` ，而 `1223` 和 `43456` **没有** 公共前缀。
>
> 你需要找出属于 `arr1` 的整数 `x` 和属于 `arr2` 的整数 `y` 组成的所有数对 `(x, y)` 之中最长的公共前缀的长度。
>
> 返回所有数对之中最长公共前缀的长度。如果它们之间不存在公共前缀，则返回 `0` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：arr1 = [1,10,100], arr2 = [1000]
> 输出：3
> 解释：存在 3 个数对 (arr1[i], arr2[j]) ：
> - (1, 1000) 的最长公共前缀是 1 。
> - (10, 1000) 的最长公共前缀是 10 。
> - (100, 1000) 的最长公共前缀是 100 。
> 最长的公共前缀是 100 ，长度为 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：arr1 = [1,2,3], arr2 = [4,4,4]
> 输出：0
> 解释：任何数对 (arr1[i], arr2[j]) 之中都不存在公共前缀，因此返回 0 。
> 请注意，同一个数组内元素之间的公共前缀不在考虑范围内。
> ```
>
>  
>
> **提示：**
>
> - `1 <= arr1.length, arr2.length <= 5 * 104`
> - `1 <= arr1[i], arr2[i] <= 108`

### 方法1

集合 + 哈希

### 思路1

将 arr1 的所有元素的所有前缀加入到集合中, 将 arr2 中所有元素的前缀向集合中匹配, 匹配后取最大值

### 代码

```Python
class Solution:
    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
        st = set()
        for s in map(str, arr1):
            for i in range(1, len(s) + 1):
                st.add(s[:i])

        ans = 0
        for s in map(str, arr2):
            for i in range(1, len(s) + 1):
                if s[:i] not in st:
                    break
                ans = max(ans, i)
        return ans
```

>  Python Tips:
>
> 1. map(func,*iterables)，返回包含若干函数值的map对象，函数func的参数分别来自于iterables指定的每个迭代对象
>
>    ```Python
>    # 定义一个函数，用于计算每个元素的平方
>    def square(x):
>        return x ** 2
>    
>    # 定义一个列表
>    numbers = [1, 2, 3, 4, 5]
>    
>    # 使用 map() 将 square 函数应用于 numbers 中的每个元素
>    squared_numbers = map(square, numbers)
>    
>    # 将结果转换为列表并输出
>    print(list(squared_numbers))
>    ```
>
>    > [1, 4, 9, 16, 25]

### 方法 2

字典树

#### 思路 2

将 arr1 化为字典树, arr2 的元素匹配前缀, 取最值

#### 代码 2

```Python
class Solution:
    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
        a = set(arr1)
        b = set(arr2)
        if len(a) > len(b):
            build, query = b, a
        else:
            build, query = a, b
        t = Trie()
        for x in build:
            t.insert(x)
        ans = 0
        for y in query:
            ans = max(ans, t.searchPrefix(y))
        return ans


class Trie:
    def __init__(self):
        self.children = [None] * 10

    def searchPrefix(self, prefix: int) -> int:
        node = self
        res = 0
        for ch in str(prefix):
            ch = ord(ch) - ord("0")
            if not node.children[ch]:
                return res
            node = node.children[ch]
            res += 1
        return res

    def insert(self, word: int) -> None:
        node = self
        for ch in str(word):
            ch = ord(ch) - ord("0")
            if not node.children[ch]:
                node.children[ch] = Trie()
            node = node.children[ch]
```



## [出现频率最高的素数](https://leetcode.cn/problems/most-frequent-prime/)

> 给你一个大小为 `m x n` 、下标从 **0** 开始的二维矩阵 `mat` 。在每个单元格，你可以按以下方式生成数字：
>
> - 最多有 `8` 条路径可以选择：东，东南，南，西南，西，西北，北，东北。
> - 选择其中一条路径，沿着这个方向移动，并且将路径上的数字添加到正在形成的数字后面。
> - 注意，每一步都会生成数字，例如，如果路径上的数字是 `1, 9, 1`，那么在这个方向上会生成三个数字：`1, 19, 191` 。
>
> 返回在遍历矩阵所创建的所有数字中，出现频率最高的、**大于** `10`的
>
> 素数
>
> ；如果不存在这样的素数，则返回 `-1` 。如果存在多个出现频率最高的素数，那么返回其中最大的那个。
>
> 
>
> **注意：**移动过程中不允许改变方向。
>
>  
>
> **示例 1：**
>
> **![img](https://assets.leetcode.com/uploads/2024/02/15/south)**
>
> ```
> 输入：mat = [[1,1],[9,9],[1,1]]
> 输出：19
> 解释： 
> 从单元格 (0,0) 出发，有 3 个可能的方向，这些方向上可以生成的大于 10 的数字有：
> 东方向: [11], 东南方向: [19], 南方向: [19,191] 。
> 从单元格 (0,1) 出发，所有可能方向上生成的大于 10 的数字有：[19,191,19,11] 。
> 从单元格 (1,0) 出发，所有可能方向上生成的大于 10 的数字有：[99,91,91,91,91] 。
> 从单元格 (1,1) 出发，所有可能方向上生成的大于 10 的数字有：[91,91,99,91,91] 。
> 从单元格 (2,0) 出发，所有可能方向上生成的大于 10 的数字有：[11,19,191,19] 。
> 从单元格 (2,1) 出发，所有可能方向上生成的大于 10 的数字有：[11,19,19,191] 。
> 在所有生成的数字中，出现频率最高的素数是 19 。
> ```
>
> **示例 2：**
>
> ```
> 输入：mat = [[7]]
> 输出：-1
> 解释：唯一可以生成的数字是 7 。它是一个素数，但不大于 10 ，所以返回 -1 。
> ```
>
> **示例 3：**
>
> ```
> 输入：mat = [[9,7,8],[4,6,5],[2,8,6]]
> 输出：97
> 解释： 
> 从单元格 (0,0) 出发，所有可能方向上生成的大于 10 的数字有: [97,978,96,966,94,942] 。
> 从单元格 (0,1) 出发，所有可能方向上生成的大于 10 的数字有: [78,75,76,768,74,79] 。
> 从单元格 (0,2) 出发，所有可能方向上生成的大于 10 的数字有: [85,856,86,862,87,879] 。
> 从单元格 (1,0) 出发，所有可能方向上生成的大于 10 的数字有: [46,465,48,42,49,47] 。
> 从单元格 (1,1) 出发，所有可能方向上生成的大于 10 的数字有: [65,66,68,62,64,69,67,68] 。
> 从单元格 (1,2) 出发，所有可能方向上生成的大于 10 的数字有: [56,58,56,564,57,58] 。
> 从单元格 (2,0) 出发，所有可能方向上生成的大于 10 的数字有: [28,286,24,249,26,268] 。
> 从单元格 (2,1) 出发，所有可能方向上生成的大于 10 的数字有: [86,82,84,86,867,85] 。
> 从单元格 (2,2) 出发，所有可能方向上生成的大于 10 的数字有: [68,682,66,669,65,658] 。
> 在所有生成的数字中，出现频率最高的素数是 97 。
> ```
>
>  
>
> **提示：**
>
> - `m == mat.length`
> - `n == mat[i].length`
> - `1 <= m, n <= 6`
> - `1 <= mat[i][j] <= 9`

### 方法

网格遍历+堆

### 思路

遍历二维数组, 遍历 8 个方向, 用字典记录所有的点和出现次数

将字典里的数据放入大顶堆中

取堆顶的数据的 key , 同时看接下来是否有出现次数一样的 key , 如果出现次数相同, 则取 key 更大值.

需要对 key 做质数校验.

### 代码

```Python
class Solution:
    def mostFrequentPrime(self, mat: List[List[int]]) -> int:
        s = defaultdict(int)
        m = len(mat)
        n = len(mat[0])
        dirc = [[-1, 0], [1, 0], [0, -1], [0, 1], [1, 1], [1, -1], [-1, 1], [-1, -1]]

        def traversal(i, j, d, res):
            if i < 0 or i >= m or j < 0 or j >= n:
                return
            res += str(mat[i][j])
            if len(res) > 1 and int(res) % 2 != 0:
                s[res] += 1
            traversal(i + d[0], j + d[1], d, res)

        def check(k):
            if k == 1: return False
            for i in range(2, int(k ** 0.5) + 1):
                if k % i == 0:
                    return False
            return True

        for i in range(m):
            for j in range(n):
                for d in dirc:
                    traversal(i, j, d, '')

        hp = [(-v, k) for k, v in s.items()]
        heapq.heapify(hp)
        mx = 0
        ans = -1
        while hp:
            if mx != 0 and hp[0][0] != mx:
                break
            v, k = heapq.heappop(hp)
            if check(int(k)):
                mx = v
                ans = max(ans, int(k))
        return ans
            
```



## [统计前后缀下标对 II](https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii/)

> 给你一个下标从 **0** 开始的字符串数组 `words` 。
>
> 定义一个 **布尔** 函数 `isPrefixAndSuffix` ，它接受两个字符串参数 `str1` 和 `str2` ：
>
> - 当 ``str1` 同时是 `str2`的前缀（prefix）和后缀（suffix）时，`isPrefixAndSuffix(str1, str2)` 返回 `true`，否则返回 `false`
>
> 例如，`isPrefixAndSuffix("aba", "ababa")` 返回 `true`，因为 `"aba"` 既是 `"ababa"` 的前缀，也是 `"ababa"` 的后缀，但是 `isPrefixAndSuffix("abc", "abcd")` 返回` false`。
>
> 以整数形式，返回满足 `i < j` 且 `isPrefixAndSuffix(words[i], words[j])` 为 `true` 的下标对 `(i, j)` 的 **数量** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：words = ["a","aba","ababa","aa"]
> 输出：4
> 解释：在本示例中，计数的下标对包括：
> i = 0 且 j = 1 ，因为 isPrefixAndSuffix("a", "aba") 为 true 。
> i = 0 且 j = 2 ，因为 isPrefixAndSuffix("a", "ababa") 为 true 。
> i = 0 且 j = 3 ，因为 isPrefixAndSuffix("a", "aa") 为 true 。
> i = 1 且 j = 2 ，因为 isPrefixAndSuffix("aba", "ababa") 为 true 。
> 因此，答案是 4 。
> ```
>
> **示例 2：**
>
> ```
> 输入：words = ["pa","papa","ma","mama"]
> 输出：2
> 解释：在本示例中，计数的下标对包括：
> i = 0 且 j = 1 ，因为 isPrefixAndSuffix("pa", "papa") 为 true 。
> i = 2 且 j = 3 ，因为 isPrefixAndSuffix("ma", "mama") 为 true 。
> 因此，答案是 2 。
> ```
>
> **示例 3：**
>
> ```
> 输入：words = ["abab","ab"]
> 输出：0
> 解释：在本示例中，唯一有效的下标对是 i = 0 且 j = 1 ，但是 isPrefixAndSuffix("abab", "ab") 为 false 。
> 因此，答案是 0 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= words.length <= 105`
> - `1 <= words[i].length <= 105`
> - `words[i]` 仅由小写英文字母组成。
> - 所有 `words[i]` 的长度之和不超过 `5 * 105` 。

### 方法1

字典树

### 思路1

因为要同时考虑是否是前缀和后缀, 可以同时将 字符串 和 字符串的逆序 组合为一对 `pair` , 对该 `pair` 进行匹配, 而不是仅针对前缀/后缀的单独的字符进行匹配.

因为有下标要求 $i<j$ , 因此可以在遍历到 j 时, 对之前建立的字典树进行匹配.

由于要记录当前字典树中匹配符合的有几个,因此字典树中还要记录当前节点下的数值.

### 代码1

```Python
class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        ans = 0
        root = Node()
        for w in words:
            cur = root
            for p in zip(w, w[::-1]):
                if p not in cur.son:
                    cur.son[p] = Node()
                cur = cur.son[p]
                ans += cur.cnt
            cur.cnt += 1
        return ans


class Node:
    __slots__ = 'son', 'cnt'
    
    def __init__(self):
        self.son = dict()
        self.cnt = 0
```

> Python Tips
>
> 1. `__slots__ = 'son', 'cnt'`  可以提升代码效率

### 方法2

Z 函数   TODO

### 思路2

### 代码2



# 第 124 场双周赛

## [修改数组后最大化数组中的连续元素数目](https://leetcode.cn/problems/maximize-consecutive-elements-in-an-array-after-modification/)

> 给你一个下标从 **0** 开始只包含 **正** 整数的数组 `nums` 。
>
> 一开始，你可以将数组中 **任意数量** 元素增加 **至多** `1` 。
>
> 修改后，你可以从最终数组中选择 **一个或者更多** 元素，并确保这些元素升序排序后是 **连续** 的。比方说，`[3, 4, 5]`是连续的，但是 `[3, 4, 6]` 和 `[1, 1, 2, 3]` 不是连续的。
>
> 请你返回 **最多** 可以选出的元素数目。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,1,5,1,1]
> 输出：3
> 解释：我们将下标 0 和 3 处的元素增加 1 ，得到结果数组 nums = [3,1,5,2,1] 。
> 我们选择元素 [3,1,5,2,1] 并将它们排序得到 [1,2,3] ，是连续元素。
> 最多可以得到 3 个连续元素。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,4,7,10]
> 输出：1
> 解释：我们可以选择的最多元素数目是 1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 106`

### 方法

值域 DP

### 思路

因为是子序列, 因此可以排序

每一个数 `nums[i]` 可以是 `nums[i]` 或 `nums[i+1]` ,

如果 `f[i]` 表示以 `i` 结尾的最长连续元素的数组的长度

那么 `f[i]` 可以从 `f[i-1]` 得到, 亦或是 通过 `f[i]` 得到 `f[i+1]`

即有 $$\begin{cases}
f[i] = f[i-1]+1\\
f[i+1] = f[i]+1
\end{cases}$$

### 代码

```Python
class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        nums.sort()
        f = defaultdict(int)
        for x in nums:
            f[x + 1] = f[x] + 1
            f[x] = f[x - 1] + 1
        return max(f.values())
```



## [相同分数的最大操作数目 II](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/)

> 给你一个整数数组 `nums` ，如果 `nums` **至少** 包含 `2` 个元素，你可以执行以下操作中的 **任意** 一个：
>
> - 选择 `nums` 中最前面两个元素并且删除它们。
> - 选择 `nums` 中最后两个元素并且删除它们。
> - 选择 `nums` 中第一个和最后一个元素并且删除它们。
>
> 一次操作的 **分数** 是被删除元素的和。
>
> 在确保 **所有操作分数相同** 的前提下，请你求出 **最多** 能进行多少次操作。
>
> 请你返回按照上述要求 **最多** 可以进行的操作次数。
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums = [3,2,1,2,3,4]
> 输出：3
> 解释：我们执行以下操作：
> - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [1,2,3,4] 。
> - 删除第一个元素和最后一个元素，分数为 1 + 4 = 5 ，nums = [2,3] 。
> - 删除第一个元素和最后一个元素，分数为 2 + 3 = 5 ，nums = [] 。
> 由于 nums 为空，我们无法继续进行任何操作。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,2,6,1,4]
> 输出：2
> 解释：我们执行以下操作：
> - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [6,1,4] 。
> - 删除最后两个元素，分数为 1 + 4 = 5 ，nums = [6] 。
> 至多进行 2 次操作。
> ```
>
>  
>
> **提示：**
>
> - `2 <= nums.length <= 2000`
> - `1 <= nums[i] <= 1000`

### 方法

区间 DP

### 思路

每一次操作按照三个方案, 进行区间的缩短

除了需要定义区间 `i` , `j` 以外, 还需要满足相同的分数 `k` , 因此还需要加入 `k` 参数 

同时记忆化搜索

### 代码

```Python
class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        @cache
        def dfs(i, j, k):
            if i >= j:
                return 0
            ans = 0
            if nums[i + 1] + nums[i] == k:
                ans = max(ans, dfs(i + 2, j, k) + 1)
            if nums[j - 1] + nums[j] == k:
                ans = max(ans, dfs(i, j - 2, k) + 1)
            if nums[i] + nums[j] == k:
                ans = max(ans, dfs(i + 1, j - 1, k) + 1)
            return ans

        n = len(nums)
        ans = max(dfs(0, n - 1, nums[0] + nums[1]), dfs(0, n - 1, nums[-1] + nums[-2]),
                  dfs(0, n - 1, nums[0] + nums[-1]))
        return ans
```



## [3039. 进行操作使字符串为空](https://leetcode.cn/problems/apply-operations-to-make-string-empty/)

> 给你一个字符串 `s` 。
>
> 请你进行以下操作直到 `s` 为 **空** ：
>
> - 每次操作 **依次** 遍历 `'a'` 到 `'z'`，如果当前字符出现在 `s` 中，那么删除出现位置 **最早** 的该字符。
>
> 请你返回进行 **最后** 一次操作 **之前** 的字符串 `s` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "aabcbbca"
> 输出："ba"
> 解释：我们进行以下操作：
> - 删除 s = "aabcbbca" 中加粗加斜字符，得到字符串 s = "abbca" 。
> - 删除 s = "abbca" 中加粗加斜字符，得到字符串 s = "ba" 。
> - 删除 s = "ba" 中加粗加斜字符，得到字符串 s = "" 。
> 进行最后一次操作之前的字符串为 "ba" 。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "abcd"
> 输出："abcd"
> 解释：我们进行以下操作：
> - 删除 s = "abcd" 中加粗加斜字符，得到字符串 s = "" 。
> 进行最后一次操作之前的字符串为 "abcd" 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 5 * 105`
> - `s` 只包含小写英文字母。

### 方法

字典统计

### 思路

因为留到最后的, 一定是出现次数最多的, 而且每次都删除最先出现的, 因此剩下的一定是最后一次出现的, 因此可以记录每个字母出现的最后位置 `last`

对出现次数最多的, 从 `last` 取得位置, 并得到答案

### 代码

```Python
class Solution:
    def lastNonEmptyString(self, s: str) -> str:
        last = {c: i for i, c in enumerate(s)}
        cnt = Counter(s)
        mx = max(cnt.values())
        ids = sorted(last[ch] for ch, c in cnt.items() if c == mx)
        return ''.join(s[i] for i in ids)
```



# 第 125 场双周赛

## [超过阈值的最少操作数 I](https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-i/)

> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。
>
> 一次操作中，你可以删除 `nums` 中的最小元素。
>
> 你需要使数组中的所有元素都大于或等于 `k` ，请你返回需要的 **最少** 操作次数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,11,10,1,3], k = 10
> 输出：3
> 解释：第一次操作后，nums 变为 [2, 11, 10, 3] 。
> 第二次操作后，nums 变为 [11, 10, 3] 。
> 第三次操作后，nums 变为 [11, 10] 。
> 此时，数组中的所有元素都大于等于 10 ，所以我们停止操作。
> 使数组中所有元素都大于等于 10 需要的最少操作次数为 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,1,2,4,9], k = 1
> 输出：0
> 解释：数组中的所有元素都大于等于 1 ，所以不需要对 nums 做任何操作。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,1,2,4,9], k = 9
> 输出：4
> 解释：nums 中只有一个元素大于等于 9 ，所以需要执行 4 次操作。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 50`
> - `1 <= nums[i] <= 109`
> - `1 <= k <= 109`
> - 输入保证至少有一个满足 `nums[i] >= k` 的下标 `i` 存在。

### 方法

循环遍历

### 思路

和顺序无关, 只要将所有小于 k 的数值剔除即可

### 代码

```Python
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        return sum(n < k for n in nums)
```

```Go

```



## [超过阈值的最少操作数 II](https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/)

> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。
>
> 一次操作中，你将执行：
>
> - 选择 `nums` 中最小的两个整数 `x` 和 `y` 。
> - 将 `x` 和 `y` 从 `nums` 中删除。
> - 将 `min(x, y) * 2 + max(x, y)` 添加到数组中的任意位置。
>
> **注意，**只有当 `nums` 至少包含两个元素时，你才可以执行以上操作。
>
> 你需要使数组中的所有元素都大于或等于 `k` ，请你返回需要的 **最少** 操作次数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,11,10,1,3], k = 10
> 输出：2
> 解释：第一次操作中，我们删除元素 1 和 2 ，然后添加 1 * 2 + 2 到 nums 中，nums 变为 [4, 11, 10, 3] 。
> 第二次操作中，我们删除元素 3 和 4 ，然后添加 3 * 2 + 4 到 nums 中，nums 变为 [10, 11, 10] 。
> 此时，数组中的所有元素都大于等于 10 ，所以我们停止操作。
> 使数组中所有元素都大于等于 10 需要的最少操作次数为 2 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,1,2,4,9], k = 20
> 输出：4
> 解释：第一次操作后，nums 变为 [2, 4, 9, 3] 。
> 第二次操作后，nums 变为 [7, 4, 9] 。
> 第三次操作后，nums 变为 [15, 9] 。
> 第四次操作后，nums 变为 [33] 。
> 此时，数组中的所有元素都大于等于 20 ，所以我们停止操作。
> 使数组中所有元素都大于等于 20 需要的最少操作次数为 4 。
> ```
>
>  
>
> **提示：**
>
> - `2 <= nums.length <= 2 * 105`
> - `1 <= nums[i] <= 109`
> - `1 <= k <= 109`
> - 输入保证答案一定存在，也就是说一定存在一个操作序列使数组中所有元素都大于等于 `k` 。

### 方法

贪心+堆

### 思路

贪心, 对数组最小堆, 如果堆顶的值小于 k, 每次对最小的两个数进行操作, 将新的值加入到堆中

### 代码

```Python
class Solution:
    def minOperations(self, h: List[int], k: int) -> int:
        ans = 0
        heapify(h)
        while h[0] < k:
            x = heappop(h)  # x 就是 min(x, y)
            heapreplace(h, x * 2 + h[0]) # h[0] 就是 max(x, y)
            ans += 1
        return ans
```



## [在带权树网络中统计可连接服务器对数目](https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/)

> 给你一棵无根带权树，树中总共有 `n` 个节点，分别表示 `n` 个服务器，服务器从 `0` 到 `n - 1` 编号。同时给你一个数组 `edges` ，其中 `edges[i] = [ai, bi, weighti]` 表示节点 `ai` 和 `bi` 之间有一条双向边，边的权值为 `weighti` 。再给你一个整数 `signalSpeed` 。
>
> 如果两个服务器 `a` ，`b` 和 `c` 满足以下条件，那么我们称服务器 `a` 和 `b` 是通过服务器 `c` **可连接的** ：
>
> - `a < b` ，`a != c` 且 `b != c` 。
> - 从 `c` 到 `a` 的距离是可以被 `signalSpeed` 整除的。
> - 从 `c` 到 `b` 的距离是可以被 `signalSpeed` 整除的。
> - 从 `c` 到 `b` 的路径与从 `c` 到 `a` 的路径没有任何公共边。
>
> 请你返回一个长度为 `n` 的整数数组 `count` ，其中 `count[i]` 表示通过服务器 `i` **可连接** 的服务器对的 **数目** 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/21/example22.png)
>
> ```
> 输入：edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
> 输出：[0,4,6,6,4,0]
> 解释：由于 signalSpeed 等于 1 ，count[c] 等于所有从 c 开始且没有公共边的路径对数目。
> 在输入图中，count[c] 等于服务器 c 左边服务器数目乘以右边服务器数目。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/21/example11.png)
>
> ```
> 输入：edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
> 输出：[2,0,0,0,0,0,2]
> 解释：通过服务器 0 ，有 2 个可连接服务器对(4, 5) 和 (4, 6) 。
> 通过服务器 6 ，有 2 个可连接服务器对 (4, 5) 和 (0, 5) 。
> 所有服务器对都必须通过服务器 0 或 6 才可连接，所以其他服务器对应的可连接服务器对数目都为 0 。
> ```
>
>  
>
> **提示：**
>
> - `2 <= n <= 1000`
> - `edges.length == n - 1`
> - `edges[i].length == 3`
> - `0 <= ai, bi < n`
> - `edges[i] = [ai, bi, weighti]`
> - `1 <= weighti <= 106`
> - `1 <= signalSpeed <= 106`
> - 输入保证 `edges` 构成一棵合法的树。

### 方法

DFS

### 思路

同 [2867. 统计树中的合法路径数目](##2867. 统计树中的合法路径数目)

枚举每一个结点, 每个结点需要算两侧的数据, 并利用乘法原理计算.

两侧的数据通过 DFS 进行计算.

因为没有聚合关系, 无法记录记忆化保存.

### 代码

```Python
class Solution:
    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
        n = len(edges) + 1
        g = [[] for _ in range(n)]
        for x, y, d in edges:
            g[x].append((y, d))
            g[y].append((x, d))

        def dfs(x, fa, l):
            nonlocal cur
            for y, d in g[x]:
                if y != fa:
                    if (l + d) % signalSpeed == 0:
                        cur += 1
                    dfs(y, x, l + d)

        ans = [0] * n
        for x in range(n):
            cnt = 0
            for y, d in g[x]:
                cur = 0
                dfs(y, x, d)
                if d % signalSpeed == 0:
                    cur += 1
                ans[x] += cnt * cur
                cnt += cur

        return ans     
```



## [3068. 最大节点价值之和](https://leetcode.cn/problems/find-the-maximum-sum-of-node-values/)

> 给你一棵 `n` 个节点的 **无向** 树，节点从 `0` 到 `n - 1` 编号。树以长度为 `n - 1` 下标从 **0** 开始的二维整数数组 `edges` 的形式给你，其中 `edges[i] = [ui, vi]` 表示树中节点 `ui` 和 `vi` 之间有一条边。同时给你一个 **正** 整数 `k` 和一个长度为 `n` 下标从 **0** 开始的 **非负** 整数数组 `nums` ，其中 `nums[i]` 表示节点 `i` 的 **价值** 。
>
> 日增哥哥想 **最大化** 树中所有节点价值之和。为了实现这一目标，日增哥哥可以执行以下操作 **任意** 次（**包括** **0 次**）：
>
> - 选择连接节点 
>
>   ```
>   u
>   ```
>
>    和 
>
>   ```
>   v
>   ```
>
>    的边 
>
>   ```
>   [u, v]
>   ```
>
>    ，并将它们的值更新为：
>
>   - `nums[u] = nums[u] XOR k`
>   - `nums[v] = nums[v] XOR k`
>
> 请你返回日增哥哥通过执行以上操作 **任意次** 后，可以得到所有节点 **价值之和** 的 **最大值** 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png)
>
> ```
> 输入：nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]
> 输出：6
> 解释：日增哥哥可以通过一次操作得到最大价值和 6 ：
> - 选择边 [0,2] 。nums[0] 和 nums[2] 都变为：1 XOR 3 = 2 ，数组 nums 变为：[1,2,1] -> [2,2,2] 。
> 所有节点价值之和为 2 + 2 + 2 = 6 。
> 6 是可以得到最大的价值之和。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/09/screenshot-2024-01-09-220017.png)
>
> ```
> 输入：nums = [2,3], k = 7, edges = [[0,1]]
> 输出：9
> 解释：日增哥哥可以通过一次操作得到最大和 9 ：
> - 选择边 [0,1] 。nums[0] 变为：2 XOR 7 = 5 ，nums[1] 变为：3 XOR 7 = 4 ，数组 nums 变为：[2,3] -> [5,4] 。
> 所有节点价值之和为 5 + 4 = 9 。
> 9 是可以得到最大的价值之和。
> ```
>
> **示例 3：**
>
> ![img](https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png)
>
> ```
> 输入：nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]
> 输出：42
> 解释：日增哥哥不需要执行任何操作，就可以得到最大价值之和 42 。
> ```
>
>  
>
> **提示：**
>
> - `2 <= n == nums.length <= 2 * 104`
> - `1 <= k <= 109`
> - `0 <= nums[i] <= 109`
> - `edges.length == n - 1`
> - `edges[i].length == 2`
> - `0 <= edges[i][0], edges[i][1] <= n - 1`
> - 输入保证 `edges` 构成一棵合法的树。

### 方法 1

树形 DP  (基于思路3）

### 思路1

一个点被异或两次，它的值就会变回去，因此每条边最多操作一次。

$f[x][0]$ 表示以 x 为根节点，进行偶数次异或的最大价值和。
$f[x][1]$ 表示以 x 为根节点，进行奇数次异或的最大价值和。

* x 偶数次异或
$f[x][0] = max(f[y][0] + nums[x], f[y][1] + nums[x] \oplus k)$
* x 奇数次异或
$f[x][1] = max(f[y][0] + nums[x] ^ k, f[y][1] + nums[x])$



### 代码1

```Python
class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        n = len(nums)
        g = [[] for _ in range(n)]
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        def dfs(son, fa):
            odd, even = nums[son] ^ k, nums[son]
            for v in g[son]:
                if v == fa:
                    continue
                codd, ceven = dfs(v, son)
                odd, even = max(odd + ceven, even + codd), max(odd + codd, even + ceven)
            return odd, even

        return dfs(0, -1)[1]
```

### 方法 2

树形DP

### 思路2

$f[x][0]$ 表示 $x$ 操作偶数次时，子树 $x$ 的除去 $x$ 的最大价值和。
$f[x][1]$ 表示 $x$ 操作奇数次时，子树 $x$ 的除去 $x$​ 的最大价值和。

#### 转移方程

* x 偶数次异或可由 偶数+子节点y不异或 / 奇数+子节点y异或
$r0 = max(f[y][0] + nums[y], f[y][1] + nums[y] \oplus k)$
$f[x][0] =f[x][0] + r0$
$f[x][0] =f[x][1] + r0$

*  x 偶数次异或可由  偶数+子节点y异或 / 奇数+子节点y不异或
$r1 = max(f[y][1] + nums[y], f[y][0] + nums[y] \oplus k)$
$f[x][0] =f[x][1] + r1$
$f[x][0] =f[x][0] + r1$

#### 边界值

$f[x][0] = 0, f[x][1] = - \infty$

#### 返回值 

根节点的 $r0$

### 代码2

```Python
class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        g = [[] for _ in nums]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        def dfs(x: int, fa: int) -> (int, int):
            f0, f1 = 0, -inf  # f[x][0] 和 f[x][1]
            for y in g[x]:
                if y != fa:
                    r0, r1 = dfs(y, x)
                    f0, f1 = max(f0 + r0, f1 + r1), max(f1 + r0, f0 + r1)
            return max(f0 + nums[x], f1 + (nums[x] ^ k)), max(f1 + nums[x], f0 + (nums[x] ^ k))
        return dfs(0, -1)[0]
```

### 方法 3

DP

### 思路3

考虑一个路径 $1-2-4-5$ , 如果对这个路径每一个节点都进行一次异或操作, 那么这个路径上的值**实际上只有头和尾进行了异或操作**.

<span style="color:red">**因此一个边的两端进行异或, 等价于对图中任意两个节点进行异或操作**</span>后, 求最大值.

且能够发现, 每次进行异或操作, 异或发生的次数直会 $+2$ $-2$ , 因此 <span style="color:red">**异或发生的次数一定是偶数**</span>

考虑使用动态规划进行解决:

$f[i][0]$ 表示前 i 个数中进行偶数次异或操作得到的最大值
$f[i][1]$ 表示前 i 个数中进行奇数次异或操作得到的最大值

#### 状态转移方程

$\begin{cases}f[i][0] = max(f[i-1][0] + nums[i], f[i-1][1] + nums[i] \oplus k)\\\\ 
f[i][1] = max(f[i-1][1] + nums[i], f[i-1][0] + nums[i] \oplus k)  \end{cases}$​

#### 初始值

$f[0][0] = 0, f[0][1] = -inf $​

#### 返回值

$f[n][0]$​

以上可以简化为一维

### 代码3
```Python
# 二维 DP
class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        n = len(edges) + 1
        f = [[0, 0] for _ in range(n+1)]
        f[0][1] = -inf
        for i in range(1, n+1):
            f[i][0] = max(f[i-1][0] + nums[i-1], f[i-1][1] + (nums[i-1] ^ k))
            f[i][1] = max(f[i-1][1] + nums[i-1], f[i-1][0] + (nums[i-1] ^ k))
        return f[n][0]
```

```Python
# 一维 DP
class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        f0, f1 = 0, -inf
        for x in nums:
           f0, f1 = max(f0+x, f1+(x^k)), max(f1+x, f0+(x^k))
        return f0
```
### 方法 4

贪心

### 思路4

同思路 2, 直接贪心, 取能通过异或操作使和变大的有哪些节点.

可以将每个数字和其异或的结果存放在数组里, 并对数组进行排序, 每次取最大的两个数, 如果两个数的和大于 0 ,说明能使答案变大.

### 代码4

```Python
class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        ans = sum(nums)
        df = sorted([(n^k) - n for n in nums])
        while len(df) >= 2 and df[-1] + df[-2] > 0:
            ans += df.pop() + df.pop()
        return ans
```





# 第387 场周赛

## 元素和小于等于 k 的子矩阵的数目

> 给你一个下标从 **0** 开始的整数矩阵 `grid` 和一个整数 `k`。
>
> 返回包含 `grid` 左上角元素、元素和小于或等于 `k` 的 **子矩阵** 的数目。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/01/example1.png)
>
> ```
> 输入：grid = [[7,6,3],[6,6,1]], k = 18
> 输出：4
> 解释：如上图所示，只有 4 个子矩阵满足：包含 grid 的左上角元素，并且元素和小于或等于 18 。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/01/example21.png)
>
> ```
> 输入：grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20
> 输出：6
> 解释：如上图所示，只有 6 个子矩阵满足：包含 grid 的左上角元素，并且元素和小于或等于 20 。
> ```
>
>  
>
> **提示：**
>
> - `m == grid.length `
> - `n == grid[i].length`
> - `1 <= n, m <= 1000 `
> - `0 <= grid[i][j] <= 1000`
> - `1 <= k <= 109`

### 方法

二维前缀和

### 思路

二维前缀和

### 代码

```Python
class Solution:
    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:        
        m, n = len(grid), len(grid[0])
        pre = [[0] * (n + 1) for _ in range(m + 1)]
        ans = 0
        for i in range(m):
            for j in range(n):
                pre[i + 1][j + 1] = pre[i][j + 1] + pre[i + 1][j] - pre[i][j] + grid[i][j]
                if pre[i + 1][j + 1] <= k:
                    ans += 1
        return ans
```

```Go

```



## 在矩阵上写出字母 Y 所需的最少操作次数

> 给你一个下标从 **0** 开始、大小为 `n x n` 的矩阵 `grid` ，其中 `n` 为奇数，且 `grid[r][c]` 的值为 `0` 、`1` 或 `2` 。
>
> 如果一个单元格属于以下三条线中的任一一条，我们就认为它是字母 **Y** 的一部分：
>
> - 从左上角单元格开始到矩阵中心单元格结束的对角线。
> - 从右上角单元格开始到矩阵中心单元格结束的对角线。
> - 从中心单元格开始到矩阵底部边界结束的垂直线。
>
> 当且仅当满足以下全部条件时，可以判定矩阵上写有字母 **Y** ：
>
> - 属于 Y 的所有单元格的值相等。
> - 不属于 Y 的所有单元格的值相等。
> - 属于 Y 的单元格的值与不属于Y的单元格的值不同。
>
> 每次操作你可以将任意单元格的值改变为 `0` 、`1` 或 `2` 。返回在矩阵上写出字母 Y 所需的 **最少** 操作次数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/22/y2.png)
>
> ```
> 输入：grid = [[1,2,2],[1,1,0],[0,1,0]]
> 输出：3
> 解释：将在矩阵上写出字母 Y 需要执行的操作用蓝色高亮显示。操作后，所有属于 Y 的单元格（加粗显示）的值都为 1 ，而不属于 Y 的单元格的值都为 0 。
> 可以证明，写出 Y 至少需要进行 3 次操作。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/22/y3.png)
>
> ```
> 输入：grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]
> 输出：12
> 解释：将在矩阵上写出字母 Y 需要执行的操作用蓝色高亮显示。操作后，所有属于 Y 的单元格（加粗显示）的值都为 0 ，而不属于 Y 的单元格的值都为 2 。
> 可以证明，写出 Y 至少需要进行 12 次操作。
> ```
>
>  
>
> **提示：**
>
> - `3 <= n <= 49`
> - `n == grid.length == grid[i].length`
> - `0 <= grid[i][j] <= 2`
> - `n` 为奇数。

### 方法

统计+暴力

### 思路

统计 Y 和非 Y 上的各颜色的数量, 循环每一种颜色, 返回最大值

### 代码

```Python
class Solution:
    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:
        y, ny = [0] * 3, [0] * 3
        n = len(grid)
        for i in range(n):
            for j in range(n):
                if (i == j and i <= n//2) or (i+j == n-1 and i <= n//2) or (i>n//2 and j == n//2):
                    y[grid[i][j]] += 1
                else:
                    ny[grid[i][j]] += 1
        ysum, nysum = sum(y), sum(ny)
        ans = inf
        for i in range(0, 3):
            for j in range(0, 3):
                if i != j:
                    ans = min(ans, nysum - ny[i] + ysum - y[j])
        return ans
```

```Go

```

### 思考

如果颜色不是3 个呢? 是 n 个树呢?

可以取 Y 和 非 Y 的最大的两个值 $cnt_{y1}, cnt_{y2}, cnt_{n1}, cnt_{n2}$, 再进行比较

如果元素不同, $cnt_{y1}+cnt_{n1}$​ 

如果元素相同, $max(cnt_{y1}+cnt_{n2}, cnt_{y2}+cnt_{n1})$ 



## 将元素分配到两个数组中 II

> 给你一个下标从 **1** 开始、长度为 `n` 的整数数组 `nums` 。
>
> 现定义函数 `greaterCount` ，使得 `greaterCount(arr, val)` 返回数组 `arr` 中 **严格大于** `val` 的元素数量。
>
> 你需要使用 `n` 次操作，将 `nums` 的所有元素分配到两个数组 `arr1` 和 `arr2` 中。在第一次操作中，将 `nums[1]` 追加到 `arr1` 。在第二次操作中，将 `nums[2]` 追加到 `arr2` 。之后，在第 `i` 次操作中：
>
> - 如果 `greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i])` ，将 `nums[i]` 追加到 `arr1` 。
> - 如果 `greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i])` ，将 `nums[i]` 追加到 `arr2` 。
> - 如果 `greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])` ，将 `nums[i]` 追加到元素数量较少的数组中。
> - 如果仍然相等，那么将 `nums[i]` 追加到 `arr1` 。
>
> 连接数组 `arr1` 和 `arr2` 形成数组 `result` 。例如，如果 `arr1 == [1,2,3]` 且 `arr2 == [4,5,6]` ，那么 `result = [1,2,3,4,5,6]` 。
>
> 返回整数数组 `result` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,1,3,3]
> 输出：[2,3,1,3]
> 解释：在前两次操作后，arr1 = [2] ，arr2 = [1] 。
> 在第 3 次操作中，两个数组中大于 3 的元素数量都是零，并且长度相等，因此，将 nums[3] 追加到 arr1 。
> 在第 4 次操作中，两个数组中大于 3 的元素数量都是零，但 arr2 的长度较小，因此，将 nums[4] 追加到 arr2 。
> 在 4 次操作后，arr1 = [2,3] ，arr2 = [1,3] 。
> 因此，连接形成的数组 result 是 [2,3,1,3] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [5,14,3,1,2]
> 输出：[5,3,1,2,14]
> 解释：在前两次操作后，arr1 = [5] ，arr2 = [14] 。
> 在第 3 次操作中，两个数组中大于 3 的元素数量都是一，并且长度相等，因此，将 nums[3] 追加到 arr1 。
> 在第 4 次操作中，arr1 中大于 1 的元素数量大于 arr2 中的数量（2 > 1），因此，将 nums[4] 追加到 arr1 。
> 在第 5 次操作中，arr1 中大于 2 的元素数量大于 arr2 中的数量（2 > 1），因此，将 nums[5] 追加到 arr1 。
> 在 5 次操作后，arr1 = [5,3,1,2] ，arr2 = [14] 。
> 因此，连接形成的数组 result 是 [5,3,1,2,14] 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [3,3,3,3]
> 输出：[3,3,3,3]
> 解释：在 4 次操作后，arr1 = [3,3] ，arr2 = [3,3] 。
> 因此，连接形成的数组 result 是 [3,3,3,3] 。
> ```
>
>  
>
> **提示：**
>
> - `3 <= n <= 105`
> - `1 <= nums[i] <= 109`

### 方法

TreeMap

### 思路

利用 TreeMap 找到每个数组严格大于当前值的个数, 按规则插入即可.

注意 TreeMap 排序时从小到大, 要想**找到严格大于的数量, 存储时应该存储负值**, 以从大到小排序. 

### 代码

```Python
from sortedcontainers import SortedList

class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        a1, a2 = [nums[0]], [nums[1]]
        s1, s2 = SortedList([-nums[0]]), SortedList([-nums[1]])
        for i in range(2, len(nums)):
            c = nums[i]
            i1 = s1.bisect_left(-c)
            i2 = s2.bisect_left(-c)
            if i1 > i2:
                a1.append(c)
                s1.add(-c)
            elif i1 < i2:
                a2.append(c)
                s2.add(-c)
            elif i1 == i2 and len(a1) > len(a2):
                a2.append(c)
                s2.add(-c)
            else:
                a1.append(c)
                s1.add(-c)
        return a1 + a2
```

```Go

```

### 复杂度分析

#### 时间复杂度

 $O(n\,log\,⁡n)$ , 其中 TreeMap 的时间代价为 $O(log\,⁡n)$

#### 空间复杂度

$O(n)$































