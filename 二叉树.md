# 二叉树

## 二叉树遍历

### 递归

* 前序遍历
* 中序遍历
* 后序遍历

### 栈

* 前序遍历
* 中序遍历
* 后序遍历

### Morris

* 前序遍历
* 中序遍历
* 后序遍历





## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：[[1]]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[0, 2000]` 内
> - `-1000 <= Node.val <= 1000`

### 方法

BFS

### 思路

按层走, 先遍历高度为0的, 再遍历高度为1, ..., 正是 **BFS** 的搜索顺序

步骤:

**(双队列)**

1. 将本层的结点加入到队列 `q` 中
2. 对 队列 `q` 中的结点进行遍历, 将值加入到结果中, 同时将子结点加入到新队列 `p` 中
3. 循环结束时,  `q = p`, 以遍历下一层.

或者 

**(单队列)**

1. 将本层的结点加入到队列 `q` 中
2. 对 队列 `q` 中的结点 `pop` `len(q)` 次, 将值加入到结果中, 同时将子结点加入到 `q` 中
3. 队列为空时, 循环结束

### 代码

```Python
# BFS 双队列
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        ans, q = [], [root]
        while q:
            ans.append(list())
            p = []
            for i in range(len(q)):
                node = q[i]
                ans[-1].append(node.val)
                if node.left:
                    p.append(node.left)
                if node.right:
                    p.append(node.right)
            q = p
        return ans
```

```Go
// BFS 双队列
func levelOrder(root *TreeNode) [][]int {
    q := []*TreeNode{root}
    res := [][]int{}
    if root == nil {
        return res
    }
    for i := 0; len(q) > 0; i++ {
        res = append(res, []int{})
        p := []*TreeNode{}
        for j := 0; j < len(q); j++ {
            node := q[j]
            res[i] = append(res[i], node.Val)
            if node.Left != nil {
                p = append(p, node.Left)
            }
            if node.Right != nil {
                p = append(p, node.Right)
            }
        }
        q = p
    }
    return res
}
```

```Python
# BFS 单队列
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue, ans = deque(), []
        queue.append(root)
        while queue:
            tmp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                tmp.append(node.val)
            ans.append(tmp)
        return ans
```

```Go
// BFS 单队列
func levelOrder(root *TreeNode) [][]int {
    q := []*TreeNode{root}
    res := [][]int{}
    if root == nil {
        return res
    }
    for i := 0; len(q) > 0; i++ {
        res = append(res, []int{})
        end := len(q)
        for j := 0; j < end; j++ {
            node := q[0]
            q = q[1:]
            res[i] = append(res[i], node.Val)
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
    }
    return res
}
```

```Python
# BFS+排序 同987垂序遍历
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        l = list()
        def bfs(root, i):
            if not root:
                return
            l.append((i, root.val))
            bfs(root.left, i+1)
            bfs(root.right, i+1)

        bfs(root, 0)
        pre = -1
        l.sort(key=lambda x: x[0])
        for x in l:
            if x[0] != pre:
                ans.append(list())
                pre = x[0]
            ans[-1].append(x[1])
        return ans
```



## [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[15,7],[9,20],[3]]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：[[1]]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[0, 2000]` 内
> - `-1000 <= Node.val <= 1000`

### 方法

BFS

### 思路

同102, 只需要将答案 reverse 即可

### 代码

```Python
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue, ans = deque(), []
        queue.append(root)
        while queue:
            tmp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                tmp.append(node.val)
            ans.append(tmp)
        return ans[::-1]
```

```Go
func levelOrderBottom(root *TreeNode) [][]int {
    ans := make([][]int, 0)
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) != 0 {
        next := []*TreeNode{}
        res := make([]int, 0)
        for i := range q {
            cur := q[i]
            res = append(res, cur.Val)
            if cur.Left != nil {
                next = append(next, cur.Left)
            }
            if cur.Right != nil {
                next = append(next, cur.Right)
            }
        }
        ans = append(ans, res)
        q = next
    }
    n := len(ans)
    for i := 0; i < n / 2; i++ {
        ans[i], ans[n - i - 1] = ans[n - i - 1], ans[i]
    }
    return ans
}
```



## [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

> 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[20,9],[15,7]]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：[[1]]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[0, 2000]` 内
> - `-100 <= Node.val <= 100`

### 方法

BFS

### 思路

层序遍历 - BFS

每个偶数(奇)层顺序改变 - 针对偶数(奇)层的数值逆序

不能对结点逆序操作, 如下图, 如果将队列中的 `[2 3]` 逆序成 `[3 2]` 后, 第三(2)层的队列将会变为 `[6 7 4 5]`

<img src="/Users/hang/Library/Application Support/typora-user-images/image-20240216005026969.png" alt="image-20240216005026969" style="zoom:50%;" />

### 代码

```Go
// 单队列
func zigzagLevelOrder(root *TreeNode) [][]int {
	l := 0
	ans := [][]int{}
	if root == nil {
		return ans
	}
	q := []*TreeNode{root}
	for len(q) > 0 {
		cur := []int{}
        end := len(q)
		for i := 0; i < end; i++{
            node := q[0]
            q = q[1:]
			cur = append(cur, node.Val)
			if node.Left != nil {
				q = append(q, node.Left)
			}
			if node.Right != nil {
				q = append(q, node.Right)
			}
		}
        if l%2 == 1 {
			reverse(cur)
		}
		ans = append(ans, cur)
		l++
	}
	return ans
}

func reverse(p []int) {
	for i := 0; i < len(p)/2; i++ {
		p[i], p[len(p)-i-1] = p[len(p)-i-1], p[i]
	}
}
```

```Go
// 双队列
func zigzagLevelOrder(root *TreeNode) [][]int {
	l := 0
	ans := [][]int{}
	if root == nil {
		return ans
	}
	q := []*TreeNode{root}
	for len(q) > 0 {
		cur := []int{}
		p := []*TreeNode{}
		for _, node := range q {
			cur = append(cur, node.Val)
			if node.Left != nil {
				p = append(p, node.Left)
			}
			if node.Right != nil {
				p = append(p, node.Right)
			}
		}
		q = p
        if l%2 == 1 {
			reverse(cur)
		}
		ans = append(ans, cur)
		l++
	}
	return ans
}

func reverse(p []int) {
	for i := 0; i < len(p)/2; i++ {
		p[i], p[len(p)-i-1] = p[len(p)-i-1], p[i]
	}
}
```



## [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)

> 给你二叉树的根结点 `root` ，请你设计算法计算二叉树的 **垂序遍历** 序列。
>
> 对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)` 。树的根结点位于 `(0, 0)` 。
>
> 二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
>
> 返回二叉树的 **垂序遍历** 序列。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[9],[3,15],[20],[7]]
> 解释：
> 列 -1 ：只有结点 9 在此列中。
> 列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
> 列  1 ：只有结点 20 在此列中。
> 列  2 ：只有结点 7 在此列中。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)
>
> ```
> 输入：root = [1,2,3,4,5,6,7]
> 输出：[[4],[2],[1,5,6],[3],[7]]
> 解释：
> 列 -2 ：只有结点 4 在此列中。
> 列 -1 ：只有结点 2 在此列中。
> 列  0 ：结点 1 、5 和 6 都在此列中。
>           1 在上面，所以它出现在前面。
>           5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。
> 列  1 ：只有结点 3 在此列中。
> 列  2 ：只有结点 7 在此列中。
> ```
>
> **示例 3：**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg)
>
> ```
> 输入：root = [1,2,3,4,6,5,7]
> 输出：[[4],[2],[1,5,6],[3],[7]]
> 解释：
> 这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。
> 因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。
> ```
>
>  
>
> **提示：**
>
> - 树中结点数目总数在范围 `[1, 1000]` 内
> - `0 <= Node.val <= 1000`

### 方法

DFS+排序

### 思路

二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置**从上到下排序**的有序列表。如果**同行同列**上有多个结点，则按结点的值从小到大进行排序。

之前的错误思路:
对每一个点遍历,获得 `col` 值, 对同一 `col` 值对节点按值排序. 这里只有 **同行同列**才排序, 如 `[3,1,4,0,2,2]` , 对于不同行的要从上到下排序

正确思路:
遍历时同时记录 行、列、结点值, 并按照 行、列、结点值的优先顺序排序.

#### 代码

```Python []
class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        nodes = list()
        def dfs(root, row, col):
            nodes.append((col, row, root.val))
            if root.left:
                dfs(root.left, row + 1, col - 1)
            if root.right:
                dfs(root.right, row + 1, col + 1)

        dfs(root, 0, 0)
        nodes.sort()
        ans, pre = list(), float('-inf')
        for col, row, value in nodes:
            if col != pre:
                pre = col
                ans.append(list())
            ans[-1].append(value)
        return ans
```

```Go []
type data struct{col, row, val int}

func verticalTraversal(root *TreeNode) [][]int {
    nodes := []data{}
    var dfs func (*TreeNode, int, int)
    dfs = func(node *TreeNode, row, col int) {
        if node == nil {
            return
        }
        nodes = append(nodes, data{col, row, node.Val})
        dfs(node.Left, row + 1, col - 1)
        dfs(node.Right, row + 1, col + 1)
    }
    dfs(root, 0, 0)

    sort.Slice(nodes, func(i, j int) bool {
        a, b := nodes[i], nodes[j]
        return a.col < b.col || (a.col == b.col && (a.row < b.row || a.row == b.row && a.val < b.val))
    })

    pre := math.MinInt32
    ans := [][]int{}

    for _, node := range nodes {
        if node.col != pre {
            pre = node.col
            ans = append(ans, nil)
        }
        ans[len(ans)-1] = append(ans[len(ans)-1], node.val)
    }

    return ans
}
```

> Go Tips:
>  * 自定义排序
> ```Go
> sort.Slice(nodes, func(i, j int) bool {
> a, b := nodes[i], nodes[j]
> return a.col < b.col || (a.col == b.col && (a.row < b.row || a.row == b.row && a.val < b.val))
> }
> ```
> * 预先定义函数 仅列参数类型
> `var dfs func (*TreeNode, int, int)`
> * 使用预先定义函数 补充参数
> `dfs = func(node *TreeNode, row, col int) {pass}`
> * 最小值
> `math.MinInt32`



## [105.从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。
>
> 
>
> **示例 1:**
>
> <img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:33%;" />
>
> ```
> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> 输出: [3,9,20,null,null,15,7]
> ```
>
> **示例 2:**
>
> ```
> 输入: preorder = [-1], inorder = [-1]
> 输出: [-1]
> ```
>
> 
>
> **提示:**
>
> - `1 <= preorder.length <= 3000`
> - `inorder.length == preorder.length`
> - `-3000 <= preorder[i], inorder[i] <= 3000`
> - `preorder` 和 `inorder` 均 **无重复** 元素
> - `inorder` 均出现在 `preorder`
> - `preorder` **保证** 为二叉树的前序遍历序列
> - `inorder` **保证** 为二叉树的中序遍历序列

### 方法

递归

### 思路

前序遍历的第一位, 一定是 root 根节点

由于无重复元素, 因此在中序遍历中找到等值的节点, 必为根节点, 同时其左侧和右侧的两部分数组, 构成了该根节点的左子树和右子树.

可以根据左子树和右子树的长度, 得到前序遍历中的左子树和右子树的数组

由于该问题可以转化为更小的子问题, 因此逐层递归即可

### 代码

```Python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not (preorder and inorder):
            return None
        root = TreeNode(preorder[0])
        x = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:x+1], inorder[:x])
        root.right = self.buildTree(preorder[x+1:], inorder[x + 1 :])
        return root
```

### 复杂度分析

#### 时间复杂度

 $O(n)$

#### 空间复杂度

$O(n)$



## [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。
>
> 
>
> **示例 1:**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)
>
> ```
> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> 输出：[3,9,20,null,null,15,7]
> ```
>
> **示例 2:**
>
> ```
> 输入：inorder = [-1], postorder = [-1]
> 输出：[-1]
> ```
>
> 
>
> **提示:**
>
> - `1 <= inorder.length <= 3000`
> - `postorder.length == inorder.length`
> - `-3000 <= inorder[i], postorder[i] <= 3000`
> - `inorder` 和 `postorder` 都由 **不同** 的值组成
> - `postorder` 中每一个值都在 `inorder` 中
> - `inorder` **保证**是树的中序遍历
> - `postorder` **保证**是树的后序遍历

### 方法

递归

### 思路

同 [105.从前序与中序遍历序列构造二叉树](##105.从前序与中序遍历序列构造二叉树)

后序遍历中最后一个节点为根节点 root

因此从中序遍历定位根节点, 分出左子树和右子树, 根据长度, 在后序遍历中切分出左子树和右子树, 并递归

### 代码

```Python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not (postorder and inorder):
            return None
        root = TreeNode(postorder[-1])
        x = inorder.index(postorder[-1])
        root.left = self.buildTree(inorder[:x], postorder[0 : x])
        root.right = self.buildTree(inorder[x + 1 :], postorder[x: -1])
        return root
```

### 复杂度分析

#### 时间复杂度

 $O(n)$

#### 空间复杂度

$O(n)$​



## 889. 根据前序和后序遍历构造二叉树

> 给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树。
>
> 如果存在多个答案，您可以返回其中 **任何** 一个。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)
>
> ```
> 输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
> 输出：[1,2,3,4,5,6,7]
> ```
>
> **示例 2:**
>
> ```
> 输入: preorder = [1], postorder = [1]
> 输出: [1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= preorder.length <= 30`
> - `1 <= preorder[i] <= preorder.length`
> - `preorder` 中所有值都 **不同**
> - `postorder.length == preorder.length`
> - `1 <= postorder[i] <= postorder.length`
> - `postorder` 中所有值都 **不同**
> - 保证 `preorder` 和 `postorder` 是同一棵二叉树的前序遍历和后序遍历

### 方法

递归

### 思路

前序：根左右 
后序：左右根
我们只能确定根节点，无法确定**左右**
我们不妨**规定， 前序遍历中根节点的下一个值就是该根节点的左子节点**

例如：
`preorder = [1,2,4,5,3,6,7] 
postorder = [4,5,2,6,7,3,1]`

$1$ 是根节点， 规定 $2$ 是 $1$ 的左子节点

这里我们不用定位根节点的位置， 因为他必是 $preorder$ 的首位或者 $postorder$ 的末尾

我们只关心其左子节点的位置应该在哪

通过在 $postorder$ 定位左子节点的位置， 我们可以在 $preorder$ 中确定左子节点和右子节点的长度

[2 4 5] [3 6 7]
[4 5 2] [6 7 3]

由于该问题可以转化为更小的子问题, 因此逐层递归即可

### 代码

```Python []
class Solution:
    def buildTree(self, p: List[int], i: List[int]) -> Optional[TreeNode]:
        if not (p and i):
            return None
        root = TreeNode(p[0])
        x = i.index(p[0])
        ileft, iright = i[:x], i[x + 1 :]
        pleft, pright = p[1 : 1 + len(ileft)], p[1 + len(ileft) :]
        root.left = self.buildTree(pleft, ileft)
        root.right = self.buildTree(pright, iright)
        return root
```

### 复杂度分析

#### 时间复杂度

 $O(n^2)$ , `index` 复杂度为 $O(n)$

#### 空间复杂度

 $O(n^2)$



## 993. 二叉树的堂兄弟节点

> 在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。
>
> 如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。
>
> 我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。
>
> 只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。
>
>  
>
> **示例 1：
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png)**
>
> ```
> 输入：root = [1,2,3,4], x = 4, y = 3
> 输出：false
> ```
>
> **示例 2：
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png)**
>
> ```
> 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
> 输出：true
> ```
>
> **示例 3：**
>
> **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png)**
>
> ```
> 输入：root = [1,2,3,null,4], x = 2, y = 3
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - 二叉树的节点数介于 `2` 到 `100` 之间。
> - 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。

### 方法

DFS

### 思路

DFS树时，记录 x 和 y 的深度和父节点，再做判断

### 代码

```Python
class Solution:
    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
        def dfs(node, l, fa):
            if not node:
                return
            if node.val == x or node.val == y:
                rd.append((l, fa))
            dfs(node.left, l+1, node)
            dfs(node.right, l+1, node)
        
        rd = []
        dfs(root, 0, None)
        return rd[0][0] == rd[1][0] and rd[0][1] != rd[1][1]
```



## [2641. 二叉树的堂兄弟节点 II](https://leetcode.cn/problems/cousins-in-binary-tree-ii/)

> 给你一棵二叉树的根 `root` ，请你将每个节点的值替换成该节点的所有 **堂兄弟节点值的和** 。
>
> 如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 **堂兄弟** 。
>
> 请你返回修改值之后，树的根 `root` 。
>
> **注意**，一个节点的深度指的是从树根节点到这个节点经过的边数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2023/01/11/example11.png)
>
> ```
> 输入：root = [5,4,9,1,10,null,7]
> 输出：[0,0,0,7,7,null,11]
> 解释：上图展示了初始的二叉树和修改每个节点的值之后的二叉树。
> - 值为 5 的节点没有堂兄弟，所以值修改为 0 。
> - 值为 4 的节点没有堂兄弟，所以值修改为 0 。
> - 值为 9 的节点没有堂兄弟，所以值修改为 0 。
> - 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。
> - 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。
> - 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2023/01/11/diagram33.png)
>
> ```
> 输入：root = [3,1,2]
> 输出：[0,0,0]
> 解释：上图展示了初始的二叉树和修改每个节点的值之后的二叉树。
> - 值为 3 的节点没有堂兄弟，所以值修改为 0 。
> - 值为 1 的节点没有堂兄弟，所以值修改为 0 。
> - 值为 2 的节点没有堂兄弟，所以值修改为 0 。
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目的范围是 `[1, 105]` 。
> - `1 <= Node.val <= 104`

### 方法

BFS

### 思路

搞懂这张图即可

![1](https://assets.leetcode-cn.com/solution-static/2641/2641_1.png)

具有相同父节点的节点互称为兄弟节点。
对于一个节点 xxx 来说，它的所有堂兄弟节点值的和，等于 xxx 这一层的所有节点值之和减去 xxx 及其兄弟节点的值之和。
因此可以通过遍历第 `n` 层时， 计算第 `n + 1` 层的同高度的节点， 若要计算第 `n` 层的堂兄弟节点节点值， 可以用 `n` 层的总值， 减去同一父节点下的两个/一个节点的值
由于并不清楚第 n 层的父节点下有几个子节点， 因此还需要遍历一遍， 获取子节点的总值是 `x` 还是 `x + y`

## 代码

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        q = [root]
        root.val = 0
        while q:
            q2 = []
            sum = 0
            for node in q:
                if node.left:
                    sum += node.left.val
                    q2.append(node.left)
                if node.right:
                    sum += node.right.val
                    q2.append(node.right)
            for node in q:
                childsum = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
                if node.left:
                    node.left.val = sum - childsum
                if node.right:
                    node.right.val = sum - childsum 
            q = q2
        return root
```

```Go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func replaceValueInTree(root *TreeNode) *TreeNode {
    q := []*TreeNode{root}
    root.Val = 0

    for len(q) > 0 {
        tmp := q
        q = nil

        sum := 0
        for _, node := range tmp {
            if node.Left != nil {
                sum += node.Left.Val
                q = append(q, node.Left)
            }
            if node.Right != nil {
                sum += node.Right.Val
                q = append(q, node.Right)
            }
        }

        for _, node := range tmp {
            child := 0
            if node.Left != nil {
                child += node.Left.Val
            }
            if node.Right != nil {
                child += node.Right.Val
            }
            if node.Left != nil {
                node.Left.Val = sum - child
            }
            if node.Right != nil {
                node.Right.Val = sum - child
            }
        }
    }

    return root
}
```

> Go Tips:
> 空为 nil
> 初始化带有初始值的数组  []*TreeNode{root}
> 减少再次初始化  使用 tmp := q 替代 同时 q = nil 来作为第二个队列



## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
>
> ```
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
> 输出：3
> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
>
> ```
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
> 输出：5
> 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [1,2], p = 1, q = 2
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[2, 105]` 内。
> - `-109 <= Node.val <= 109`
> - 所有 `Node.val` `互不相同` 。
> - `p != q`
> - `p` 和 `q` 均存在于给定的二叉树中。

### 方法

递归

### 思路



### 代码

```Python

```



# 二叉搜索树

## 2476. 二叉搜索树最近节点查询

> 给你一个 **二叉搜索树** 的根节点 `root` ，和一个由正整数组成、长度为 `n` 的数组 `queries` 。
>
> 请你找出一个长度为 `n` 的 **二维** 答案数组 `answer` ，其中 `answer[i] = [mini, maxi]` ：
>
> - `mini` 是树中小于等于 `queries[i]` 的 **最大值** 。如果不存在这样的值，则使用 `-1` 代替。
> - `maxi` 是树中大于等于 `queries[i]` 的 **最小值** 。如果不存在这样的值，则使用 `-1` 代替。
>
> 返回数组 `answer` 。
>
>  
>
> **示例 1 ：**
>
> ![img](https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png)
>
> ```
> 输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]
> 输出：[[2,2],[4,6],[15,-1]]
> 解释：按下面的描述找出并返回查询的答案：
> - 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。
> - 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。
> - 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。
> ```
>
> **示例 2 ：**
>
> ![img](https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png)
>
> ```
> 输入：root = [4,null,9], queries = [3]
> 输出：[[-1,4]]
> 解释：树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。
> ```
>
>  
>
> **提示：**
>
> - 树中节点的数目在范围 `[2, 105]` 内
> - `1 <= Node.val <= 106`
> - `n == queries.length`
> - `1 <= n <= 105`
> - `1 <= queries[i] <= 106`

### 方法

树中序遍历+二分

### 思路

**由于题目没说二叉搜索树是平衡的，最坏情况下这棵树是一条链，此时单次询问的复杂度是 $O(n)$ 的**，其中 $n$ 为二叉搜索树的节点个数。

 因此先使用中序遍历得到有序数组，再对每一次进行二分操作.

 ### 代码
 ```Python []
 class Solution:
    def closestNodes(
        self, root: Optional[TreeNode], queries: List[int]
    ) -> List[List[int]]:
        a = []

        def dfs(node: Optional[TreeNode]) -> None:
            if node is None:
                return
            dfs(node.left)
            a.append(node.val)
            dfs(node.right)

        dfs(root)

        n = len(a)
        ans = []
        for q in queries:
            j = bisect_left(a, q)
            mx = a[j] if j < n else -1
            if j == n or a[j] != q:  # a[j]>q, a[j-1]<q
                j -= 1
            mn = a[j] if j >= 0 else -1
            ans.append([mn, mx])
        return ans
 ```

> Python Tips
>
> - bisect.**bisect_left**(*a*, *x*, *lo=0*, *hi=len(a)*, ***, *key=None*)
>
>   a 中 插入 x 时, x 插入哪里使序列仍然有序 (左侧优先)
>
>   限制  <span style="color:red">$lo >= 0, hi <= len(a)$</span> , 即 点可以插入的位置, 最远是 $len(a)$​



## [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
> 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
> ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)
>
> 示例 1:
>
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
> 输出: 6 
> 解释: 节点 2 和节点 8 的最近公共祖先是 6。
> 示例 2:
>
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
> 输出: 2
> 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
>
>
> 说明:
>
> 所有节点的值都是唯一的。
> p、q 为不同节点且均存在于给定的二叉搜索树中。

### 方法

DFS

### 思路

如果 $p$ 和 $q$ 的大小都小于 $root$ 那么公共父节点一定在 $root$ 的左子树中; 

都大于 $root$ 那么公共父节点一定在 $root$ 的右子树中; 

如果是在 $root$ 的两侧,那么 $root$ 就是这个公共父节点.

### 代码

```Python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```







# 树

## [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。
>
> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
>
>  
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,null,3,2,4,null,5,6]
> 输出：[[1],[3,2,4],[5,6]]
> ```
>
> **示例 2：**
>
> <img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
> ```
>
>  
>
> **提示：**
>
> - 树的高度不会超过 `1000`
> - 树的节点总数在 `[0, 10^4]` 之间

### 方法

BFS

### 思路

同 [102. 二叉树的层序遍历](##102. 二叉树的层序遍历)

### 代码

```Python
class Solution:
    def levelOrder(self, root: "Node") -> List[List[int]]:
        if not root:
            return []
        q = deque([root])
        ans = []
        while q:
            l = []
            for _ in range(len(q)):
                cur = q.popleft()
                l.append(cur.val)
                for n in cur.children:
                    if n:
                        q.append(n)
            ans.append(l)
        return ans
```

```Go
func levelOrder(root *Node) [][]int {
    if root == nil {
        return [][]int{}
    }
    q := []*Node{root}
    ans := [][]int{}
    for len(q) > 0 {
        l := []int{}
        e := len(q)
        for i := 0; i < e; i++ {
            cur := q[0]
            q = q[1:]
            l = append(l, cur.Val)
            for _, n := range cur.Children {
                if n != nil {
                    q = append(q, n)
                }
            }
        }
        ans = append(ans, l)
    }
    return ans
}
```

### 复杂度分析

#### 时间复杂度

 $O(n)$ 

#### 空间复杂度

$O(n)$​, 这里用了队列



## [2867. 统计树中的合法路径数目](https://leetcode.cn/problems/count-valid-paths-in-a-tree/)

> 给你一棵 `n` 个节点的无向树，节点编号为 `1` 到 `n` 。给你一个整数 `n` 和一个长度为 `n - 1` 的二维整数数组 `edges` ，其中 `edges[i] = [ui, vi]` 表示节点 `ui`和 `vi` 在树中有一条边。
>
> 请你返回树中的 **合法路径数目** 。
>
> 如果在节点 `a` 到节点 `b` 之间 **恰好有一个** 节点的编号是质数，那么我们称路径 `(a, b)` 是 **合法的** 。
>
> **注意：**
>
> - 路径 `(a, b)` 指的是一条从节点 `a` 开始到节点 `b` 结束的一个节点序列，序列中的节点 **互不相同** ，且相邻节点之间在树上有一条边。
> - 路径 `(a, b)` 和路径 `(b, a)` 视为 **同一条** 路径，且只计入答案 **一次** 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2023/08/27/example1.png)
>
> ```
> 输入：n = 5, edges = [[1,2],[1,3],[2,4],[2,5]]
> 输出：4
> 解释：恰好有一个质数编号的节点路径有：
> - (1, 2) 因为路径 1 到 2 只包含一个质数 2 。
> - (1, 3) 因为路径 1 到 3 只包含一个质数 3 。
> - (1, 4) 因为路径 1 到 4 只包含一个质数 2 。
> - (2, 4) 因为路径 2 到 4 只包含一个质数 2 。
> 只有 4 条合法路径。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2023/08/27/example2.png)
>
> ```
> 输入：n = 6, edges = [[1,2],[1,3],[2,4],[3,5],[3,6]]
> 输出：6
> 解释：恰好有一个质数编号的节点路径有：
> - (1, 2) 因为路径 1 到 2 只包含一个质数 2 。
> - (1, 3) 因为路径 1 到 3 只包含一个质数 3 。
> - (1, 4) 因为路径 1 到 4 只包含一个质数 2 。
> - (1, 6) 因为路径 1 到 6 只包含一个质数 3 。
> - (2, 4) 因为路径 2 到 4 只包含一个质数 2 。
> - (3, 6) 因为路径 3 到 6 只包含一个质数 3 。
> 只有 6 条合法路径。
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 105`
> - `edges.length == n - 1`
> - `edges[i].length == 2`
> - `1 <= ui, vi <= n`
> - 输入保证 `edges` 形成一棵合法的树。

### 方法1

DFS+埃氏筛+乘法原理

### 思路1

#### 埃氏筛

判断是否为质数，使用埃氏筛

在筛数值的范围 $n$，找出以内的质数。先用 $2$ 去筛，即把 $2$ 留下，把 $2$ 的倍数剔除掉；再用下一个质数，也就是 $3$ 筛，把 $3$ 留下，把 $3$ 的倍数剔除掉；接下去用下一个质数 $5$ 筛，把 $5$ 留下，把 $5$ 的倍数剔除掉；不断重复下去......。

每次起始剔除， 从 $i^2$ 开始， 因为 $[i, i^2]$ 内的数据已被之前的数筛选过。

因此枚举时，从 $[2,  \lfloor\sqrt{n}\rfloor]$ 中的质数

代码：

```Python []
def prime(n):
        is_prime = [True] * (n+1)
        is_prime[1] = False
        for i in range(2, isqrt(n+1) + 1):
            if is_prime[i]:
                for j in range(i * i, n+1, i):
                    is_prime[j] = False
```

#### DFS

考虑枚举每一个节点

* 节点是非质数，我们还需要去找这个节点关联的路径质数只有一个，不好判断
* 节点是质数，只存在一个质数的条件已经成立，因此我们只需要找到路径都为非质数的路径即可

如果一个值为质数的节点，能找到其连接的存在非质数的子树，那么这些子树中任意两个子树中的节点可以连成一个满足题干的路径，如果其连接的子树的路径个数分别为 4、6、7， 那么可以使用乘法原理进行计算。注意不要忘记从质数出发到各子树也是符合题意的。

步骤：

1. 遍历每个节点，找到质数节点
2. 找到质数节点的相连的节点，作为子树的起点，找到所有只包含非质数的节点
3. 对节点个数乘法原理计算
4. 同时为了避免计算同一个作为非质数的节点的连通块的大小，可以类似记忆化搜索，存储该连通块内节点的值。

### 代码1

```Python
# DFS
MX = 10**5 + 1
is_prime = [True] * MX
is_prime[1] = False
for i in range(2, isqrt(MX) + 1):
    if is_prime[i]:
        for x in range(i * i, MX, i):
            is_prime[x] = False


class Solution:

    def countPaths(self, n: int, edges: List[List[int]]) -> int:
        g = [[] for _ in range(n + 1)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        def dfs(x, fa, nodes):
            nodes.append(x)
            for y in g[x]:
                if y != fa and not is_prime[y]:
                    dfs(y, x, nodes)

        ans = 0
        size = [0] * (n + 1)
        for x in range(1, n + 1):
            if not is_prime[x]:
                continue
            s = 0
            for y in g[x]:
                if is_prime[y]:
                    continue
                if size[y] == 0:
                    nodes = []
                    dfs(y, -1, nodes)
                    for node in nodes:
                        size[node] = len(nodes)
                ans += s * size[y]
                s += size[y]
            ans += s
        return ans
```

```Go
// DFS
const MX = 1e5 + 1

var not_prime = [MX]bool{1: true}

func init() {
	for i := 2; i*i < MX; i++ {
		if !not_prime[i] {
			for j := i * i; j < MX; j += i {
				not_prime[j] = true
			}
		}
	}
}

func countPaths(n int, edges [][]int) int64 {
	g := make([][]int, n+1)
	for _, e := range edges {
		g[e[0]] = append(g[e[0]], e[1])
		g[e[1]] = append(g[e[1]], e[0])
	}
	var dfs func(int, int, *[]int)
	dfs = func(x int, fa int, nodes *[]int) {
		*nodes = append(*nodes, x)
		for _, y := range g[x] {
			if y != fa && not_prime[y] {
				dfs(y, x, nodes)
			}
		}
	}
	ans := 0
	size := make([]int, n+1)
	for i := 1; i <= n; i++ {
		if !not_prime[i] {
			s := 0
			for _, x := range g[i] {
				if !not_prime[x] {
					continue
				}
				if size[x] == 0 {
					nodes := []int{}
					dfs(x, -1, &nodes)
					for _, n := range nodes {
						size[n] = len(nodes)
					}
				}
				ans += s * size[x]
				ans += size[x]
				s += size[x]
			}
		}
	}
	return int64(ans)
}
```

> Go Tips:
>
> - 数组初始化，指定大小，某个数据初始化  `[MX]bool{1: true}`
> - 初始化函数 `func init(){}`
> - 指数 `1e5 (10**5)`
> - 数组作为参数传递时，请使用指针

### 方法2

并查集

### 思路2

同上述分析，我们可以预先将所有非质数的节点连接到一个连通块内，这样再遍历质数节点是，可以快速拿到其连接的非质数的连通块的大小。

### 代码2

```Python
MX = 10**5 + 1
is_prime = [True] * MX
is_prime[1] = False
for i in range(2, isqrt(MX)+1):
    if is_prime[i]:
        for j in range(i * i, MX, i):
            is_prime[j] = False

class UnionFind:
    def __init__(self, n):
        self.p = [i for i in range(n)]
        self.cnt = [1] * n

    def find(self, x):
        if x != self.p[x]:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.cnt[px] > self.cnt[py]:
            self.p[px] = py
            self.cnt[py] += self.cnt[px]
        else:
            self.p[py] = px
            self.cnt[px] += self.cnt[py]
        return True


class Solution:
    def countPaths(self, n: int, edges: List[List[int]]) -> int:
        g = [[] for _ in range(n + 1)]
        uf = UnionFind(n+1)
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)
            if not is_prime[x] and not is_prime[y]:
                uf.union(x, y)
        
        ans = 0
        for x in range(1, n + 1):
            if is_prime[x]:
                s = 0
                for y in g[x]:
                    if not is_prime[y]:
                        c = uf.cnt[uf.find(y)]
                        ans += s * c
                        ans += c
                        s += c
        return ans
```

```Go
// 并查集
const MX = 1e5 + 1

var not_prime = [MX]bool{1: true}

func init() {
	for i := 2; i*i < MX; i++ {
		if !not_prime[i] {
			for j := i * i; j < MX; j += i {
				not_prime[j] = true
			}
		}
	}
}

type unionfind struct{ p, size []int }

func newUnionFind(n int) *unionfind {
	p := make([]int, n)
	size := make([]int, n)
	for i := range p {
		p[i] = i
		size[i] = 1
	}
	return &unionfind{p, size}
}

func (uf *unionfind) find(x int) int {
	if x != uf.p[x] {
		uf.p[x] = uf.find(uf.p[x])
	}
	return uf.p[x]
}

func (uf *unionfind) union(x, y int) bool {
	px, py := uf.find(x), uf.find(y)
	if px == py {
		return false
	}
	uf.p[px] = py
	uf.size[py] += uf.size[px]
	return true
}

func countPaths(n int, edges [][]int) int64 {
	g := make([][]int, n+1)
	uf := newUnionFind(n + 1)
	for _, e := range edges {
		x, y := e[0], e[1]
		g[x] = append(g[x], y)
		g[y] = append(g[y], x)
		if not_prime[x] && not_prime[y] {
			uf.union(x, y)
		}
	}
	var ans int64
	for i := 1; i <= n; i++ {
		if !not_prime[i] {
			s := 0
			for _, x := range g[i] {
				if not_prime[x] {
					k := uf.size[uf.find(x)]
					ans += int64(s*k + k)
					s += k
				}
			}
		}
	}
	return ans
}
```



## 在带权树网络中统计可连接服务器对数目

> 给你一棵无根带权树，树中总共有 `n` 个节点，分别表示 `n` 个服务器，服务器从 `0` 到 `n - 1` 编号。同时给你一个数组 `edges` ，其中 `edges[i] = [ai, bi, weighti]` 表示节点 `ai` 和 `bi` 之间有一条双向边，边的权值为 `weighti` 。再给你一个整数 `signalSpeed` 。
>
> 如果两个服务器 `a` ，`b` 和 `c` 满足以下条件，那么我们称服务器 `a` 和 `b` 是通过服务器 `c` **可连接的** ：
>
> - `a < b` ，`a != c` 且 `b != c` 。
> - 从 `c` 到 `a` 的距离是可以被 `signalSpeed` 整除的。
> - 从 `c` 到 `b` 的距离是可以被 `signalSpeed` 整除的。
> - 从 `c` 到 `b` 的路径与从 `c` 到 `a` 的路径没有任何公共边。
>
> 请你返回一个长度为 `n` 的整数数组 `count` ，其中 `count[i]` 表示通过服务器 `i` **可连接** 的服务器对的 **数目** 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/21/example22.png)
>
> ```
> 输入：edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
> 输出：[0,4,6,6,4,0]
> 解释：由于 signalSpeed 等于 1 ，count[c] 等于所有从 c 开始且没有公共边的路径对数目。
> 在输入图中，count[c] 等于服务器 c 左边服务器数目乘以右边服务器数目。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2024/01/21/example11.png)
>
> ```
> 输入：edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
> 输出：[2,0,0,0,0,0,2]
> 解释：通过服务器 0 ，有 2 个可连接服务器对(4, 5) 和 (4, 6) 。
> 通过服务器 6 ，有 2 个可连接服务器对 (4, 5) 和 (0, 5) 。
> 所有服务器对都必须通过服务器 0 或 6 才可连接，所以其他服务器对应的可连接服务器对数目都为 0 。
> ```
>
>  
>
> **提示：**
>
> - `2 <= n <= 1000`
> - `edges.length == n - 1`
> - `edges[i].length == 3`
> - `0 <= ai, bi < n`
> - `edges[i] = [ai, bi, weighti]`
> - `1 <= weighti <= 106`
> - `1 <= signalSpeed <= 106`
> - 输入保证 `edges` 构成一棵合法的树。

### 方法

DFS+乘法原理

### 思路

同 [2867. 统计树中的合法路径数目](##2867. 统计树中的合法路径数目)

枚举每一个结点, 每个结点需要算两侧的数据, 并利用乘法原理计算.

两侧的数据通过 DFS 进行计算.

因为没有聚合关系, 无法记录记忆化保存.

### 代码

```Python
class Solution:
    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
        n = len(edges) + 1
        g = [[] for _ in range(n)]
        for x, y, d in edges:
            g[x].append((y, d))
            g[y].append((x, d))

        def dfs(x, fa, l):
            nonlocal cur
            for y, d in g[x]:
                if y != fa:
                    if (l + d) % signalSpeed == 0:
                        cur += 1
                    dfs(y, x, l + d)

        ans = [0] * n
        for x in range(n):
            cnt = 0
            for y, d in g[x]:
                cur = 0
                dfs(y, x, d)
                if d % signalSpeed == 0:
                    cur += 1
                ans[x] += cnt * cur
                cnt += cur

        return ans
            
```

