# 反悔贪心

## 浅谈

贪心的思想, 使用堆保存最值.







## [1383. 最大的团队表现值](https://leetcode.cn/problems/maximum-performance-of-a-team/) [2091]

> 给定两个整数 `n` 和 `k`，以及两个长度为 `n` 的整数数组 `speed` 和` efficiency`。现有 `n` 名工程师，编号从 `1` 到 `n`。其中 `speed[i]` 和 `efficiency[i]` 分别代表第 `i` 位工程师的速度和效率。
>
> 从这 `n` 名工程师中最多选择 `k` 名不同的工程师，使其组成的团队具有最大的团队表现值。
>
> **团队表现值** 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。
>
> 请你返回该团队的最大团队表现值，由于答案可能很大，请你返回结果对 `10^9 + 7` 取余后的结果。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
> 输出：60
> 解释：
> 我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3
> 输出：68
> 解释：
> 此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4
> 输出：72
> ```
>
>  
>
> **提示：**
>
> - `1 <= k <= n <= 10^5`
> - `speed.length == n`
> - `efficiency.length == n`
> - `1 <= speed[i] <= 10^5`
> - `1 <= efficiency[i] <= 10^8`

### 方法

反悔贪心+排序

### 思路

求 $sum(speed) * min(efficiency)$ 的最大值

首先题中任选 `k` 个人, 不关心顺序, 因此可以排序

考虑按哪个值排序?

1. 按照 $speed$ 排序, 同时维护 $efficiency$​​ , 留 `k` 个最小值

   如果按照 $speed$ 降序, 先保证 $sum(speed)$ 为最大值, 只有当 $efficiency_i$ 比当前的 $efficiency$ 堆中个的最小值要大时, 才有可能更新到最大值.

   同时因为需要从记录  $sum(speed)$ 的变量中剔除掉最小值对应的 $speed_{min\_eff}$​, 还需要记录 $speed$ 和 $efficiency$ 的对应关系, 实现繁杂.

2. 按照 $efficiency$ 排序, 同时维护 $speed$​ 的值, 留 `k` 个最大值

   $efficiency$  **降序**后, 可以保证当前遍历到的 $efficiency_i$ 一定是遍历过的**前 `i` 个中最小的**

   $speed$​ 使用**小顶堆**维护, 当新值插入后弹出最小值, 保证剩余的都是当前的最大值

因此使用第二种方式排序

### 代码

```Python
class Solution:
    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
        hp = []
        ttl, ans = 0, 0
        for e, s in sorted(zip(efficiency, speed), key=lambda x: -x[0]):
            heapq.heappush(hp, s)
            ttl += s
            if len(hp) > k:
                ttl -= heapq.heappop(hp)
            ans = max(ans, e * ttl)
        return ans % (10**9 + 7)
```

### 复杂度分析

#### 时间复杂度

 $O(n\,log\,⁡n)$ , 其中排序的时间代价为 $O(n\,log\,⁡n)$，后面的操作中每个元素进出堆的次数最多一次，所以总的时间代价是  $O(n\,log\,⁡n)$。

#### 空间复杂度

$O(n)$​, 这里用了堆







