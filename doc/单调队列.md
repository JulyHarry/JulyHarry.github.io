# 单调队列

## 使用要求

<span style="color:red;font-size:30px">**及时移除无用数据，保证队列/栈有序**</span>



## 性质

- 移除最左边的元素
- 移除最右边的元素
- 最右边插入元素
- 队首到队尾具有单调性

- <span style='color:red'>**队列中一般记录数组的下标**</span>

- 因为是双端队列, 只要保证, <span style="color:red">**一侧弹出且最值, 一侧增删**</span>, 队首队尾自己定



## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回 *滑动窗口中的最大值* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1], k = 1
> 输出：[1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
> - `1 <= k <= nums.length`

### 方法

滑动窗口+单调队列

### 思路

如果数组值为 `[1, 2, 3, 7, 4, 2, 3]`, 获取滑动窗口内的最大值
在窗口滑出 $7$ 之前，最大值都会是 $7$， 只要在 $7$ 左侧比他小的的数，我们永远不会选取，
因此当遍历到 $7$ 时， 须将比 $7$ 小的所有数据清除，**需要从数据结果的右侧移除较小值、插入较大值**。
同时因为窗口长度有限，对于**超出窗口的值应及时清理，需要从左侧移除**；
对每一个数据进行遍历时，会保证这个数据结构是单调递减的。
满足以上的数据结构即 **单调队列**

<span style='color:red'>**队列中记录数组的下标**</span>，保证队首元素在窗口内

* 	队首元素序号 `i` , 当前遍历序号 `j` ，如果 `j - i + 1 > k` 则超出窗口

配合滑动窗口模板

* 入
* 出
* 记录答案

### 代码

```Python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []
        q = deque()

        # 滑动窗口
        for i, n in enumerate(nums):
            # 入
            while q and nums[q[-1]] < n:
                q.pop()
            q.append(i)
            # 出
            if i - q[0] + 1 > k:
                q.popleft()
            # 记录
            if i >= k - 1:
                ans.append(nums[q[0]])

        return ans
```
```Go
func maxSlidingWindow(nums []int, k int) []int {
        ans := []int{}
        q := []int{}

        // 滑动窗口
        for i, n := range nums{
            // 入
            for len(q) > 0 && nums[q[len(q)-1]] < n{
                q = q[:len(q)-1]
            }
            q = append(q, i)
            // 出
            if i - q[0] + 1 > k{
                q = q[1:]
            }
            // 记录
            if i >= k - 1{
                ans = append(ans, nums[q[0]])
            }
        }
        return ans
}
```

### 复杂度分析

#### 时间复杂度

$O(n)$

#### 空间复杂度

$O(n)$



## [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) [1672]

> 给你一个整数数组 `nums` ，和一个表示限制的整数 `limit`，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 `limit` *。*
>
> 如果不存在满足条件的子数组，则返回 `0` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [8,2,4,7], limit = 4
> 输出：2 
> 解释：所有子数组如下：
> [8] 最大绝对差 |8-8| = 0 <= 4.
> [8,2] 最大绝对差 |8-2| = 6 > 4. 
> [8,2,4] 最大绝对差 |8-2| = 6 > 4.
> [8,2,4,7] 最大绝对差 |8-2| = 6 > 4.
> [2] 最大绝对差 |2-2| = 0 <= 4.
> [2,4] 最大绝对差 |2-4| = 2 <= 4.
> [2,4,7] 最大绝对差 |2-7| = 5 > 4.
> [4] 最大绝对差 |4-4| = 0 <= 4.
> [4,7] 最大绝对差 |4-7| = 3 <= 4.
> [7] 最大绝对差 |7-7| = 0 <= 4. 
> 因此，满足题意的最长子数组的长度为 2 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [10,1,2,4,7,2], limit = 5
> 输出：4 
> 解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 <= 5 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [4,2,2,2,4,4,2,2], limit = 0
> 输出：3
> ```

### 方法1

滑动窗口+单调队列

### 思路1

<span style="color:red">**连续子数组 - 可以考虑滑动窗口**</span>

窗口中, 当 r 右移后, 维护两个单调队列(最大、最小), 当超出 limit 时, 弹出与 nums[l] 相等的最大值/最小值, 直至满足为止

**因为本题的窗口出的限制是: 最大值与最小值, 和数组下标无关, 所以本题队列中直接存最值.**

### 代码1

```Python
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        mx, mn = deque(), deque()
        l, ans = 0, 0
        for r, num in enumerate(nums):
            while mx and num > mx[-1]:
                mx.pop()
            mx.append(num)
            while mn and num < mn[-1]:
                mn.pop()
            mn.append(num)
            while mx[0] - mn[0] > limit:
                if nums[l] == mx[0]:
                    mx.popleft()
                if nums[l] == mn[0]:
                    mn.popleft()
                l += 1
            ans = max(ans, r - l + 1)
        return ans
```

```Go
func longestSubarray(nums []int, limit int) int {
	mx, mn := []int{}, []int{}
	l, ans := 0, 0
	for r, num := range nums {
		for len(mx) > 0 && num > mx[len(mx)-1] {
			mx = mx[:len(mx)-1]
		}
		mx = append(mx, num)
		for len(mn) > 0 && num < mn[len(mn)-1] {
			mn = mn[:len(mn)-1]
		}
		mn = append(mn, num)
		for mx[0]-mn[0] > limit {
			if nums[l] == mx[0] {
				mx = mx[1:]
			}
			if nums[l] == mn[0] {
				mn = mn[1:]
			}
			l += 1
		}
		ans = max(ans, r-l+1)
	}
    return ans
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}
```

### 复杂度分析1

#### 时间复杂度

$O(n)$ ，其中 $n$ 是数组长度。最多遍历该数组两次，两个单调队列入队出队次数也均为 $O(n)$。

#### 空间复杂度

$O(n)$ ，其中 $n$​ 是数组长度。最坏情况下有序集合将和原数组等大。

### 方法2

见 平衡树



## [2398. 预算内的最多机器人数目](https://leetcode.cn/problems/maximum-number-of-robots-within-budget/) [1917]

> 你有 `n` 个机器人，给你两个下标从 **0** 开始的整数数组 `chargeTimes` 和 `runningCosts` ，两者长度都为 `n` 。第 `i` 个机器人充电时间为 `chargeTimes[i]` 单位时间，花费 `runningCosts[i]` 单位时间运行。再给你一个整数 `budget` 。
>
> 运行 `k` 个机器人 **总开销** 是 `max(chargeTimes) + k * sum(runningCosts)` ，其中 `max(chargeTimes)` 是这 `k` 个机器人中最大充电时间，`sum(runningCosts)` 是这 `k` 个机器人的运行时间之和。
>
> 请你返回在 **不超过** `budget` 的前提下，你 **最多** 可以 **连续** 运行的机器人数目为多少。
>
>  
>
> **示例 1：**
>
> ```
> 输入：chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25
> 输出：3
> 解释：
> 可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。
> 选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。
> 可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19
> 输出：0
> 解释：即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。
> ```
>
>  
>
> **提示：**
>
> - `chargeTimes.length == runningCosts.length == n`
> - `1 <= n <= 5 * 104`
> - `1 <= chargeTimes[i], runningCosts[i] <= 105`
> - `1 <= budget <= 1015`

### 方法

滑动窗口+单调队列

### 思路

本题的 ~~连续~~ 是指 连续子数组, 那么可以考虑使用滑动窗口

`r` 移入窗口时, 维护最大值和 `sum` 值, 最大值通过单调队列维护, 超出限制时, `l` 右移, 如果超出 `l` 范围, 队首移除, 并且更新 `sum` 值

### 代码

```Python
class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        l, ans, rc = 0, 0, 0
        q = deque()
        for r, ct in enumerate(chargeTimes):
            while q and ct > chargeTimes[q[-1]]:
                q.pop()
            q.append(r)
            rc += runningCosts[r]
            while q and chargeTimes[q[0]] + (r - l + 1) * rc > budget:
                if q[0] == l:
                    q.popleft()
                rc -= runningCosts[l]
                l += 1
            ans = max(ans, r - l + 1)
        return ans
```

```Go
func maximumRobots(chargeTimes []int, runningCosts []int, budget int64) int {
    l, ans, s := 0, 0, 0
    q := []int{}
    for r, ct := range chargeTimes{
        s += runningCosts[r]
        for len(q) > 0 && ct > chargeTimes[q[len(q)-1]] {
            q = q[:len(q)-1]
        }
        q = append(q, r)
        for len(q) > 0 && int64(chargeTimes[q[0]] + (r-l+1)*s) > budget {
            s -= runningCosts[l]
            if q[0] == l {
                q = q[1:]
            }
            l += 1
        }
        ans = max(ans, r-l+1)
    }
    return ans
}

func max(a, b int) int {if a < b {return b}; return a}
```

### 复杂度分析

#### 时间复杂度

$O(n)$

#### 空间复杂度

$O(n)$

### 思考

如果不是子数组, 是子序列呢?

思路和 [1383. 最大的团队表现值](https://leetcode.cn/problems/maximum-performance-of-a-team/) (反悔贪心)是类似的。

#### 代码

```Python
class Solution:
    def maximumRobotsSubseq(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        ans = sum_cost = 0
        h = []  # 最大堆，堆顶表示当前的最大花费，从而贪心地在不满足要求的情况下，优先去掉最大的花费
        for t, c in sorted(zip(chargeTimes, runningCosts)):  # 按照时间排序，从而保证当前的时间是最大的，在此之前的机器人都是可以选的
            heappush(h, -c)
            sum_cost += c
            while h and t + len(h) * sum_cost > budget:
                sum_cost += heappop(h)  # 弹出一个最大花费，即使弹出的是当前的 c 也没关系，这不会得到更大的 ans
            ans = max(ans, len(h))
        return ans
```



## [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/) [2306]

> 给你一个整数数组 `nums` 和一个整数 `k` ，找出 `nums` 中和至少为 `k` 的 **最短非空子数组** ，并返回该子数组的长度。如果不存在这样的 **子数组** ，返回 `-1` 。
>
> **子数组** 是数组中 **连续** 的一部分。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1], k = 1
> 输出：1
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2], k = 4
> 输出：-1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [2,-1,2], k = 3
> 输出：3
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-105 <= nums[i] <= 105`
> - `1 <= k <= 109`

### 方法

单调队列

### 思路

**由于本题中元素有可能是负数, 因此不能使用滑动窗口解决.**

**涉及子数组和可以使用前缀和解决.**

可以通过暴力法, 但会超时.

优化一：

<img src="https://pic.leetcode.cn/1666668814-ikkWBN-862-1-2.png" alt="862-1-2.png" style="zoom: 67%;" />

优化二：

<img src="https://pic.leetcode.cn/1666669250-KypIVI-862-2-3.png" alt="862-2-3.png" style="zoom:67%;" />

做完这两个优化后，再把 `s[i]` 加到这个数据结构中。

由于优化二保证了数据结构中的 `s[i]` 会形成一个递增的序列，因此优化一移除的是序列最左侧的若干元素，优化二移除的是序列最右侧的若干元素。我们需要一个数据结构，它支持移除最左端的元素和最右端的元素，以及在最右端添加元素，故选用双端队列。

### 代码

```Python
class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        n = len(nums)
        pre = [0] * (n+1)
        ans = inf
        for i in range(n):
            pre[i+1] = pre[i]+nums[i]
        q = deque()
        for i, num in enumerate(pre):
            while q and num - pre[q[0]] >= k:
                ans = min(ans, i-q.popleft())
            while q and num <= pre[q[-1]]:
                q.pop()
            q.append(i)
        return  ans if ans < inf else -1
```

```Go
func shortestSubarray(nums []int, k int) int {
	ans := math.MaxInt
	n := len(nums)
	pre := make([]int, n+1)
	for i, num := range nums {
		pre[i+1] = pre[i] + num
	}
	q := []int{}
	for i, s := range pre {
		for len(q) > 0 && s-pre[q[0]] >= k {
			ans = min(ans, i-q[0])
			q = q[1:]
		}
		for len(q) > 0 && pre[q[len(q)-1]] >= s {
			q = q[:len(q)-1]
		}
		q = append(q, i)
	}
	if ans == math.MaxInt {
		return -1
	}
	return ans
}
```

### 复杂度分析

#### 时间复杂度

 $O(n)$ 

#### 空间复杂度

$O(n)$



## [1499. 满足不等式的最大值](https://leetcode.cn/problems/max-value-of-equation/) [2456]

> 给你一个数组 `points` 和一个整数 `k` 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 `points[i] = [xi, yi]` ，并且在 `1 <= i < j <= points.length` 的前提下， `xi < xj` 总成立。
>
> 请你找出 `yi + yj + |xi - xj|` 的 **最大值**，其中 `|xi - xj| <= k` 且 `1 <= i < j <= points.length`。
>
> 题目测试数据保证至少存在一对能够满足 `|xi - xj| <= k` 的点。
>
>  
>
> **示例 1：**
>
> ```
> 输入：points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
> 输出：4
> 解释：前两个点满足 |xi - xj| <= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。
> 没有其他满足条件的点，所以返回 4 和 1 中最大的那个。
> ```
>
> **示例 2：**
>
> ```
> 输入：points = [[0,0],[3,0],[9,2]], k = 3
> 输出：3
> 解释：只有前两个点满足 |xi - xj| <= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。
> ```
>
>  
>
> **提示：**
>
> - `2 <= points.length <= 10^5`
> - `points[i].length == 2`
> - `-10^8 <= points[i][0], points[i][1] <= 10^8`
> - `0 <= k <= 2 * 10^8`
> - 对于所有的`1 <= i < j <= points.length` ，`points[i][0] < points[j][0]` 都成立。也就是说，`xi` 是严格递增的。

### 方法1

单调队列

### 思路1

$y_i + y_j + |x_i - x_j| \iff y_i + y_j + x_j - x_i \iff (y_j+x_j)+(y_i-x_i)$​​ , 其中 $i < j$

$j$ 是当前遍历的下标, $i$ 是遍历过程中的最大值的下标

① 如果 $x_j - x_i > k$ , 那么需要最左侧的 $i$ 弹出

② 如果当前的 $y_i-x_i < y_j-x_j$​ , 那么也需要将最右侧的 $i$​ 弹出

计算结果时, 首先要肯定满足 ①, 才能对新遍历的值进行计算最大值, 再判断 ② , 整理单调队列

### 代码1

```Python
class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        q = deque()
        ans = -inf
        for x, y in points:
            while q and x - q[0][0] > k:
                q.popleft()
            if q:
                ans = max(ans, x + y + q[0][1])
            while q and y - x > q[-1][1]:
                q.pop()
            q.append((x, y-x))
        return ans
```

```Go
func findMaxValueOfEquation(points [][]int, k int) int {
	ans := math.MinInt32
	type pair struct{ x, yx int }
	q := []pair{}
	for _, p := range points {
		for len(q) > 0 && p[0]-q[0].x > k {
			q = q[1:]
		}
		if len(q) > 0 {
			ans = max(ans, q[0].yx+p[0]+p[1])
		}
		for len(q) > 0 && q[len(q)-1].yx < p[1]-p[0] {
			q = q[:len(q)-1]
		}
		q = append(q, pair{p[0], p[1] - p[0]})
	}
	return ans
}
```

### 复杂度分析1

#### 时间复杂度

 $O(n)$ 

#### 空间复杂度

$O(n)$

### 方法2

堆

### 思路2

同思路 1 获取 $ (y_j+x_j)+(y_i-x_i)$ 的最大值

可以将之前的下标 $i$ 对应的 $(x_i,  y_i-x_i)$ 记录

python 的 heap 是小顶堆, 因此要获取  $(y_i-x_i)$ 的最大值, 应该存储 $(x_i-y_i)$​ 

堆首是 $(y_i-x_i)$ 的最大值,  如果其  $x_i$ 超出限制,  需舍弃

### 代码2

```Python
class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        hp = []
        ans = -inf
        for x, y in points:
            while hp and x - hp[0][1] > k:
                heapq.heappop(hp)
            if hp:
                ans = max(ans, x + y - hp[0][0])
            heapq.heappush(hp, [x-y, x])
        return ans
```

### 复杂度分析2

#### 时间复杂度

 $O(n\,log\,⁡n)$ 

#### 空间复杂度

$O(n)$​



# 单调队列 DP

<span style="color:red">**出转入**</span> - 出队列 转移方程 入队列

## [1696. 跳跃游戏 VI](https://leetcode.cn/problems/jump-game-vi) [1954]

### 方法

滑动窗口+单调队列+动态规划

### 思路

动态规划的转移方程为  $f[i] = max(f[i], f[i-j])$ , $j ∈ [1, k]$

但是时间复杂度 $O(n * k)$

如果使用单调队列,  $f[i] = f[q[0]] + nums[i]$

1. **先出后入**

​	判读单调队列中的序号是否超出 ( $i - q[0] > k$ ) ，超出则要舍弃
​	更新 `f` 数组, 将此值加入到单调队列中

2. **先入后出**

   更新 `f` 数组, 将此值加入到单调队列中

   判读单调队列中的序号是否超出  ( $i - q[0] > k - 1$ ) ，超出则要舍弃

### 总结

与 [239. 滑动窗口最大值](##239. 滑动窗口最大值) 的区别:

239中最大值出现在**原数组**中, 不需要额外数组记录, 而1696我们需要的最大值来自**动态规划**的数组.

### 代码

```Python
# 先出后入
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n = len(nums)
        f = [0] * n
        f[0] = nums[0]
        q = deque([0])
        for i in range(1, n):
            # 1. 出
            if i - q[0] > k:
                q.popleft()
            # 2. 转移
            f[i] = f[q[0]] + nums[i]
            # 3. 入
            while q and f[i] >= f[q[-1]]:
                q.pop()
            q.append(i)
        return f[-1]
```

```Go
// 先出后入
func maxResult(nums []int, k int) int {
    n := len(nums)
    f := make([]int, n)
    f[0] = nums[0]
    q := []int{0}
    for i := 1; i < n; i++ {
        // 1. 出
        if q[0] < i-k {
            q = q[1:]
        }
        // 2. 转移
        f[i] = f[q[0]] + nums[i]
        // 3. 入
        for len(q) > 0 && f[i] >= f[q[len(q)-1]] {
            q = q[:len(q)-1]
        }
        q = append(q, i)
    }
    return f[n-1]
}
```

```Go
// 先入后出
func maxResult(nums []int, k int) int {
	n := len(nums)
	f := make([]int, n)
	f[0] = nums[0]
	q := []int{0}
	for r := 1; r < n; r++ {
        // 转移
		f[r] = f[q[0]] + nums[r]
        // 入
		for len(q) > 0 && f[r] > f[q[len(q)-1]] {
			q = q[:len(q)-1]
		}
		q = append(q, r)
        // 出
		if r-q[0] > k-1 {
			q = q[1:]
		}
	}
	return f[n-1]
}
```

### 复杂度分析

#### 时间复杂度

$O(n)$

#### 空间复杂度

$O(n)$​



## [2944. 购买水果需要的最少金币数](https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/) [1708]

> 你在一个水果超市里，货架上摆满了玲琅满目的奇珍异果。
>
> 给你一个下标从 **1** 开始的数组 `prices` ，其中 `prices[i]` 表示你购买第 `i` 个水果需要花费的金币数目。
>
> 水果超市有如下促销活动：
>
> - 如果你花费 `price[i]` 购买了水果 `i` ，那么接下来的 `i` 个水果你都可以免费获得。
>
> **注意** ，即使你 **可以** 免费获得水果 `j` ，你仍然可以花费 `prices[j]` 个金币去购买它以便能免费获得接下来的 `j` 个水果。
>
> 请你返回获得所有水果所需要的 **最少** 金币数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：prices = [3,1,2]
> 输出：4
> 解释：你可以按如下方法获得所有水果：
> - 花 3 个金币购买水果 1 ，然后免费获得水果 2 。
> - 花 1 个金币购买水果 2 ，然后免费获得水果 3 。
> - 免费获得水果 3 。
> 注意，虽然你可以免费获得水果 2 ，但你还是花 1 个金币去购买它，因为这样的总花费最少。
> 购买所有水果需要最少花费 4 个金币。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,10,1,1]
> 输出：2
> 解释：你可以按如下方法获得所有水果：
> - 花 1 个金币购买水果 1 ，然后免费获得水果 2 。
> - 免费获得水果 2 。
> - 花 1 个金币购买水果 3 ，然后免费获得水果 4 。
> - 免费获得水果 4 。
> 购买所有水果需要最少花费 2 个金币。
> ```
>
>  
>
> **提示：**
>
> - `1 <= prices.length <= 1000`
> - `1 <= prices[i] <= 105`

### 方法

动态规划+单调队列

### 思路

注意 $i$ 从 $1$​ 开始。

#### 从前往后考虑:

$dp[i]$ 表示买前 $i$ 个水果所需的最小花费.

如果不买第 i 个水果:

$dp[i] = dp[i]$

如果买第 $i$ 个水果:

$dp[i] = dp[i-1] + prices[i-1]$

并且要更新 $[i+1, 2i]$ 的金额:

$dp[j] = min(dp[j],\;dp[i-1] + prices[i-1])$​

初始值: $dp[0] = 0$    (注意不是 $dp[1] = prices[0]$, 因为要通过第一位来更新后方的值)

返回值: $dp[n]$

#### 从前往后考虑 - 状态转移:

用 $dp[i][0]$ 表示买前 $i$ 个水果且不买第 $i$ 个水果的最少金币数

用 $dp[i][1]$ 表示买前 $i$ 个水果且买第 $i$​ 个水果的最少金币数

买第 $i$ 个水果就是从前 $i-1$ 个水果的范围内价格最少的加上第 $i$​ 个水果

$dp[i][1] = min(dp[i-1][0] ,dp[i-1][1]) + prices[i-1]$

不买第 $i$ 个水果就前面可以赠送的范围内选价格最少的

$dp[i][0] = min_{j=\lceil\dfrac{i}{2}\rceil}^{i-1}(dp[j][1])$​​

初始值: $dp[1][1] = prices[0]$ , 其余值初始化为最大值

返回结果: $dp[n][0]$ (如果只有数组只有一个值, 会返回inf, 因此可以返回 $min(f[n][0], f[n][1])$ )

#### 从后往前考虑递归:

我们需要解决的问题是：「获得第 $1$ 个及其后面的水果所需要的最少金币数」。

第 $1$ 个水果一定要买，然后呢？

第 $2$ 个水果可以购买，也可以免费获得：

- 如果购买，那么需要解决的问题为：「获得第 $2$ 个及其后面的水果所需要的最少金币数」。

- 如果免费获得，那么需要解决的问题为：「获得第 $3$ 个及其后面的水果所需要的最少金币数」。

无论哪种情况都会把原问题变成一个和原问题相似的、规模更小的子问题，所以可以用递归解决。

从上面的讨论可以知道，只需要一个参数 $i$ 就能表达子问题，即定义 $dfs(i)$ 表示获得第 $i$ 个及其后面的水果所需要的最少金币数。

第 $i$ 个水果一定要买，那么从 $i+1$ 到 $2i$ 的水果都是免费的。枚举下一个需要购买的水果 $j$，它的范围是 $[i+1,2i+1]$。

所有情况取最小值，再加上购买第 $i$ 个水果需要的金币 $prices[i]$，就得到了 $dfs(i)$ 。即

${dfs}(i) = \textit{prices}[i] + \min_{j=i+1}^{2i+1} \textit{dfs}(j)$

注意到当 $2i≥n$，即 $i\ge \lceil\dfrac{n}{2}\rceil = \lfloor\dfrac{n+1}{2}\rfloor$  时，后面的水果都可以免费获得了，所以递归边界为

 $\textit{dfs}(i)=\textit{prices}[i], i\ge \left\lfloor\dfrac{n+1}{2}\right\rfloor$

递归入口：$\textit{dfs}(1)$​，也就是答案。

#### 从后往前考虑递推:

$$dp[i] =\begin{cases}
prices[i-1],\; i+i>=n\\\\
min_{i+1}^{2i+2}(dp[j]) + prices[i-1],\; i+i < n\end{cases}$$​​​​​

返回值: $dp[1]$

#### 从后往前考虑递推-单调队列优化:

因为最小值会在 $min_{i+1}^{2i+2}(dp[j])$ 中循环找出, 但是范围 $[i+1, 2i+2]$ 是一个会随 $i$​ 变小的逐渐向左的滑动窗口

类似于 [滑动窗口最大值](##239. 滑动窗口最大值]) 的思路: 

从左向右的滑动窗口的最大值

- 队首对应左边界, 超出窗口时弹出, 队首为最大值
- 队尾对应右边界,  不断增删

本题从右向左的滑动窗口的最小值  **因为是双端队列, 只要保证一侧弹出且最值, 一侧增删即可, 队首队尾可以自定**

本题既可以是:

- 队首对应左边界, 不断增删
- 队尾对应右边界, 超出窗口时弹出, 队尾为最小值

也可以是:

- 队首超出窗口时弹出, 队首为最小值
- 队尾不断增删

为了可以判断是否超出窗口  $[i+1, 2i+2]$ , 需要记录数组的下标

为了可以判断大小, 还需要记录 $dp$​ 值

因此队列中需要保存 $(i, dp[i])$

为避免单独列举 $dp[i] =prices[i-1],\; i+i>=n$ 的情况, 由于 $dp[i] = prices[i-1] = 0 + prices[i-1]$

可以在队列中**加入哨兵** $(n+1, 0)$ 

**由于加入哨兵, 队列中一定会存在数据, 因此不用再判断队列中是否有值了**

返回值: 假设对应第一种情况(队尾为最小值), 因为**原本要返回的值为 $dp[1]$** , 而现在**增删是在队首, 因此返回 $dp[0][1]$**

同理第二种情况(队首为最小值), 增删在队尾, 返回 $dp[-1][1]$

### 代码

```Python
# 从前往后考虑
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        f = [float('inf')] * (n+1)
        f[0] = 0
        for i in range(1, n+1):
            buy = f[i-1] + prices[i-1]
            f[i] = min(f[i], buy)
            for j in range(i+1, min(n+1, 2*i+1)):
                f[j] = min(f[j], buy)
        return f[n]
```

```Python
# 从前往后考虑 - 状态转移
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        f = [[float('inf'), float('inf')] for _ in range(n+1)]
        f[1][1] = prices[0]
        for i in range(2, n+1):
            f[i][1] = min(f[i-1][0], f[i-1][1]) + prices[i-1]
            for j in range((i+1)//2, i+1):
                f[i][0] = min(f[i][0], f[j][1])
        return min(f[n][0], f[n][1])
```

```Python
# 从后往前考虑递归
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        
        @cache
        def dfs(i):
            if i + i >= n:
                return prices[i-1]
            return min(dfs(j) for j in range(i+1, i*2+2)) + prices[i-1]
        
        return dfs(1)
```

```Python
# 从后往前考虑递归2
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        
        @cache
        def dfs(i):
            if i > n:
                return 0
            res = inf
            for j in range(i+1, i*2+2):
                res = min(res, dfs(j))
            return res + prices[i-1]
        
        return dfs(1)
```

```Python
# 从后往前考虑递推
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        f = [0] * (n+1)
        for i in range(n, 0, -1):
            if i + i >= n:
                f[i] = prices[i-1]
            else:
                f[i] = min(f[j] for j in range(i+1, i*2+2)) + prices[i-1]
        return f[1]
```

```Python
# 从后往前考虑递推-单调队列优化-队尾最小
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        q = deque([(n + 1, 0)])  # 哨兵
        for i in range(n, 0, -1):
            while q[-1][0] > i * 2 + 1:
                q.pop()
            f = prices[i - 1] + q[-1][1]
            while f <= q[0][1]:
                q.popleft()
            q.appendleft((i, f))
        return q[0][1]
```

```Python
# 从后往前考虑递推-单调队列优化-队首最小
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        q = deque([(n + 1, 0)])  # 哨兵
        for i in range(n, 0, -1):
            while q[0][0] > i * 2 + 1:
                q.popleft()
            f = prices[i - 1] + q[0][1]
            while f <= q[-1][1]:
                q.pop()
            q.append((i, f))
        return q[-1][1]
```



## [1425. 带限制的子序列和](https://leetcode.cn/problems/constrained-subsequence-sum/) [2032]

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回 **非空** 子序列元素和的最大值，子序列需要满足：子序列中每两个 **相邻** 的整数 `nums[i]` 和 `nums[j]` ，它们在原数组中的下标 `i` 和 `j` 满足 `i < j` 且 `j - i <= k` 。
>
> 数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [10,2,-10,5,20], k = 2
> 输出：37
> 解释：子序列为 [10, 2, 5, 20] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [-1,-2,-3], k = 1
> 输出：-1
> 解释：子序列必须是非空的，所以我们选择最大的数字。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [10,-2,-10,-5,20], k = 2
> 输出：23
> 解释：子序列为 [10, -2, -5, 20] 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= k <= nums.length <= 10^5`
> - `-10^4 <= nums[i] <= 10^4`

### 方法

### 思路

### 代码

```Python

```

```Go

```

### 复杂度分析

#### 时间复杂度

 $O(n\,log\,⁡n)$ , 其中排序的时间代价为 $O(n\,log\,⁡n)$，后面的操作中每个元素进出堆的次数最多一次，所以总的时间代价是  $O(n\,log\,⁡n)$。

#### 空间复杂度

$O(n)$, 这里用了堆



## [375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)

> 我们正在玩一个猜数游戏，游戏规则如下：
>
> 1. 我从 `1` 到 `n` 之间选择一个数字。
> 2. 你来猜我选了哪个数字。
> 3. 如果你猜到正确的数字，就会 **赢得游戏** 。
> 4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
> 5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。
>
> 给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。
>
>  
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2020/09/10/graph.png" alt="img" style="zoom:50%;" />
>
> ```
> 输入：n = 10
> 输出：16
> 解释：制胜策略如下：
> - 数字范围是 [1,10] 。你先猜测数字为 7 。
>     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
>     - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
>         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
>         - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
>         - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
>     - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
>         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
>         - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
>             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
>             - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
>             - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
>         - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
>             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
>             - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
> 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：0
> 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：有两个可能的数字 1 和 2 。
> - 你可以先猜 1 。
>     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
>     - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
> 最糟糕的情况下，你需要支付 $1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 200`

### 方法

### 思路

### 代码

```Python

```

```Go

```

### 复杂度分析

#### 时间复杂度

 $O(n\,log\,⁡n)$ , 其中排序的时间代价为 $O(n\,log\,⁡n)$，后面的操作中每个元素进出堆的次数最多一次，所以总的时间代价是  $O(n\,log\,⁡n)$。

#### 空间复杂度

$O(n)$, 这里用了堆







- [ ] LeetCode 1687. 从仓库到码头运输箱子 2610
- [ ] LeetCode 2945. 找到最大非递减数组的长度 2943